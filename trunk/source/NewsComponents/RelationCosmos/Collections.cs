#region CVS Version Header
/*
 * $Id$
 * Last modified by $Author$
 * Last modified at $Date$
 * $Revision$
 */
#endregion

//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

using System;
using System.Collections;

using RssComponents.RelationCosmos;

namespace RssComponents.Collections
{
	

	/// <summary>
	///		A strongly-typed collection of <see cref="string"/> objects.
	/// </summary>
	[Serializable]
public 
  class RelationHRefList : ICollection, IList, IEnumerable, ICloneable
	{
        #region Interfaces
	    /// <summary>
	    ///		Supports type-safe iteration over a <see cref="RelationHRefList"/>.
	    /// </summary>
        public interface IRelationHRefListEnumerator
        {
		    /// <summary>
		    ///		Gets the current element in the collection.
		    /// </summary>
            string Current {get;}

		    /// <summary>
		    ///		Advances the enumerator to the next element in the collection.
		    /// </summary>
		    /// <exception cref="InvalidOperationException">
		    ///		The collection was modified after the enumerator was created.
		    /// </exception>
		    /// <returns>
		    ///		<c>true</c> if the enumerator was successfully advanced to the next element; 
		    ///		<c>false</c> if the enumerator has passed the end of the collection.
		    /// </returns>
            bool MoveNext();

		    /// <summary>
		    ///		Sets the enumerator to its initial position, before the first element in the collection.
		    /// </summary>
            void Reset();
        }
        #endregion

		private const int DEFAULT_CAPACITY = 16;

		#region Implementation (data)
		private string[] m_array;
		private int m_count = 0;
		[NonSerialized]
		private int m_version = 0;
		#endregion
	
        #region Static Wrappers
		/// <summary>
		///		Creates a synchronized (thread-safe) wrapper for a 
		///     <c>RelationHRefList</c> instance.
		/// </summary>
		/// <returns>
		///     An <c>RelationHRefList</c> wrapper that is synchronized (thread-safe).
		/// </returns>
        public static RelationHRefList Synchronized(RelationHRefList list)
        {
            if(list==null)
                throw new ArgumentNullException("list");
            return new SyncRelationHRefList(list);
        }
        
		/// <summary>
		///		Creates a read-only wrapper for a 
		///     <c>RelationHRefList</c> instance.
		/// </summary>
		/// <returns>
		///     An <c>RelationHRefList</c> wrapper that is read-only.
		/// </returns>
        public static RelationHRefList ReadOnly(RelationHRefList list)
        {
            if(list==null)
                throw new ArgumentNullException("list");
            return new ReadOnlyRelationHRefList(list);
        }
        #endregion

	    #region Construction
		/// <summary>
		///		Initializes a new instance of the <c>RelationHRefList</c> class
		///		that is empty and has the default initial capacity.
		/// </summary>
		public RelationHRefList()
		{
			m_array = new string[DEFAULT_CAPACITY];
		}
		
		/// <summary>
		///		Initializes a new instance of the <c>RelationHRefList</c> class
		///		that has the specified initial capacity.
		/// </summary>
		/// <param name="capacity">
		///		The number of elements that the new <c>RelationHRefList</c> is initially capable of storing.
		///	</param>
		public RelationHRefList(int capacity)
		{
			m_array = new string[capacity];
		}

		/// <summary>
		///		Initializes a new instance of the <c>RelationHRefList</c> class
		///		that contains elements copied from the specified <c>RelationHRefList</c>.
		/// </summary>
		/// <param name="c">The <c>RelationHRefList</c> whose elements are copied to the new collection.</param>
		public RelationHRefList(RelationHRefList c)
		{
			m_array = new string[c.Count];
			AddRange(c);
		}

		/// <summary>
		///		Initializes a new instance of the <c>RelationHRefList</c> class
		///		that contains elements copied from the specified <c>System.Collections.ICollection</c>.
		/// </summary>
		/// <param name="c">The <c>System.Collections.ICollection</c> whose elements are copied to the new collection.</param>
		public RelationHRefList(System.Collections.ICollection c)
		{
			m_array = new string[c.Count];
			AddRange(c);
		}

		/// <summary>
		///		Initializes a new instance of the <c>RelationHRefList</c> class
		///		that contains elements copied from the specified <see cref="string"/> array.
		/// </summary>
		/// <param name="a">The <see cref="string"/> array whose elements are copied to the new list.</param>
		public RelationHRefList(string[] a)
		{
			m_array = new string[a.Length];
			AddRange(a);
		}
		
        protected enum Tag {
            Default
        }

        protected RelationHRefList(Tag t)
        {
            m_array = null;
        }
		#endregion
		
		#region Operations (type-safe ICollection)
		/// <summary>
		///		Gets the number of elements actually contained in the <c>RelationHRefList</c>.
		/// </summary>
		public virtual int Count
		{
			get { return m_count; }
		}

		/// <summary>
		///		Copies the entire <c>RelationHRefList</c> to a one-dimensional
		///		<see cref="string"/> array.
		/// </summary>
		/// <param name="array">The one-dimensional <see cref="string"/> array to copy to.</param>
		public virtual void CopyTo(string[] array)
		{
			this.CopyTo(array, 0);
		}

		/// <summary>
		///		Copies the entire <c>RelationHRefList</c> to a one-dimensional
		///		<see cref="string"/> array, starting at the specified index of the target array.
		/// </summary>
		/// <param name="array">The one-dimensional <see cref="string"/> array to copy to.</param>
		/// <param name="start">The zero-based index in <paramref name="array"/> at which copying begins.</param>
		public virtual void CopyTo(string[] array, int start)
		{
			if (m_count > array.GetUpperBound(0) + 1 - start)
				throw new System.ArgumentException("Destination array was not long enough.");
			
			Array.Copy(m_array, 0, array, start, m_count); 
		}

		/// <summary>
		///		Gets a value indicating whether access to the collection is synchronized (thread-safe).
		/// </summary>
		/// <returns>true if access to the ICollection is synchronized (thread-safe); otherwise, false.</returns>
        public virtual bool IsSynchronized
        {
            get { return m_array.IsSynchronized; }
        }

        /// <summary>
		///		Gets an object that can be used to synchronize access to the collection.
		/// </summary>
        public virtual object SyncRoot
        {
            get { return m_array.SyncRoot; }
        }
		#endregion
		
		#region Operations (type-safe IList)
		/// <summary>
		///		Gets or sets the <see cref="string"/> at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index of the element to get or set.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="RelationHRefList.Count"/>.</para>
		/// </exception>
		public virtual string this[int index]
		{
			get
			{
				ValidateIndex(index); // throws
				return m_array[index]; 
			}
			set
			{
				ValidateIndex(index); // throws
				++m_version; 
				m_array[index] = value; 
			}
		}

		/// <summary>
		///		Adds a <see cref="string"/> to the end of the <c>RelationHRefList</c>.
		/// </summary>
		/// <param name="item">The <see cref="string"/> to be added to the end of the <c>RelationHRefList</c>.</param>
		/// <returns>The index at which the value has been added.</returns>
		public virtual int Add(string item)
		{
			if (m_count == m_array.Length)
				EnsureCapacity(m_count + 1);

			m_array[m_count] = item;
			m_version++;

			return m_count++;
		}
		
		/// <summary>
		///		Removes all elements from the <c>RelationHRefList</c>.
		/// </summary>
		public virtual void Clear()
		{
			++m_version;
			m_array = new string[DEFAULT_CAPACITY];
			m_count = 0;
		}
		
		/// <summary>
		///		Creates a shallow copy of the <see cref="RelationHRefList"/>.
		/// </summary>
		public virtual object Clone()
		{
			RelationHRefList newColl = new RelationHRefList(m_count);
			Array.Copy(m_array, 0, newColl.m_array, 0, m_count);
			newColl.m_count = m_count;
			newColl.m_version = m_version;

			return newColl;
		}

		/// <summary>
		///		Determines whether a given <see cref="string"/> is in the <c>RelationHRefList</c>.
		/// </summary>
		/// <param name="item">The <see cref="string"/> to check for.</param>
		/// <returns><c>true</c> if <paramref name="item"/> is found in the <c>RelationHRefList</c>; otherwise, <c>false</c>.</returns>
		public virtual bool Contains(string item)
		{
			for (int i=0; i != m_count; ++i)
				if (m_array[i].Equals(item))
					return true;
			return false;
		}

		/// <summary>
		///		Returns the zero-based index of the first occurrence of a <see cref="string"/>
		///		in the <c>RelationHRefList</c>.
		/// </summary>
		/// <param name="item">The <see cref="string"/> to locate in the <c>RelationHRefList</c>.</param>
		/// <returns>
		///		The zero-based index of the first occurrence of <paramref name="item"/> 
		///		in the entire <c>RelationHRefList</c>, if found; otherwise, -1.
		///	</returns>
		public virtual int IndexOf(string item)
		{
			for (int i=0; i != m_count; ++i)
				if (m_array[i].Equals(item))
					return i;
			return -1;
		}

		/// <summary>
		///		Inserts an element into the <c>RelationHRefList</c> at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
		/// <param name="item">The <see cref="string"/> to insert.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="RelationHRefList.Count"/>.</para>
		/// </exception>
		public virtual void Insert(int index, string item)
		{
			ValidateIndex(index, true); // throws
			
			if (m_count == m_array.Length)
				EnsureCapacity(m_count + 1);

			if (index < m_count)
			{
				Array.Copy(m_array, index, m_array, index + 1, m_count - index);
			}

			m_array[index] = item;
			m_count++;
			m_version++;
		}

		/// <summary>
		///		Removes the first occurrence of a specific <see cref="string"/> from the <c>RelationHRefList</c>.
		/// </summary>
		/// <param name="item">The <see cref="string"/> to remove from the <c>RelationHRefList</c>.</param>
		/// <exception cref="ArgumentException">
		///		The specified <see cref="string"/> was not found in the <c>RelationHRefList</c>.
		/// </exception>
		public virtual void Remove(string item)
		{		   
			int i = IndexOf(item);
			if (i < 0)
				throw new System.ArgumentException("Cannot remove the specified item because it was not found in the specified Collection.");
			
			++m_version;
			RemoveAt(i);
		}

		/// <summary>
		///		Removes the element at the specified index of the <c>RelationHRefList</c>.
		/// </summary>
		/// <param name="index">The zero-based index of the element to remove.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="RelationHRefList.Count"/>.</para>
		/// </exception>
		public virtual void RemoveAt(int index)
		{
			ValidateIndex(index); // throws
			
			m_count--;

			if (index < m_count)
			{
				Array.Copy(m_array, index + 1, m_array, index, m_count - index);
			}
			
			// We can't set the deleted entry equal to null, because it might be a value type.
			// Instead, we'll create an empty single-element array of the right type and copy it 
			// over the entry we want to erase.
			string[] temp = new string[1];
			Array.Copy(temp, 0, m_array, m_count, 1);
			m_version++;
		}

		/// <summary>
		///		Gets a value indicating whether the collection has a fixed size.
		/// </summary>
		/// <value>true if the collection has a fixed size; otherwise, false. The default is false</value>
        public virtual bool IsFixedSize
        {
            get { return false; }
        }

		/// <summary>
		///		gets a value indicating whether the IList is read-only.
		/// </summary>
		/// <value>true if the collection is read-only; otherwise, false. The default is false</value>
        public virtual bool IsReadOnly
        {
            get { return false; }
        }
		#endregion

		#region Operations (type-safe IEnumerable)
		
		/// <summary>
		///		Returns an enumerator that can iterate through the <c>RelationHRefList</c>.
		/// </summary>
		/// <returns>An <see cref="Enumerator"/> for the entire <c>RelationHRefList</c>.</returns>
		public virtual IRelationHRefListEnumerator GetEnumerator()
		{
			return new Enumerator(this);
		}
		#endregion

		#region Public helpers (just to mimic some nice features of ArrayList)
		
		/// <summary>
		///		Gets or sets the number of elements the <c>RelationHRefList</c> can contain.
		/// </summary>
		public virtual int Capacity
		{
			get { return m_array.Length; }
			
			set
			{
				if (value < m_count)
					value = m_count;

				if (value != m_array.Length)
				{
					if (value > 0)
					{
						string[] temp = new string[value];
						Array.Copy(m_array, temp, m_count);
						m_array = temp;
					}
					else
					{
						m_array = new string[DEFAULT_CAPACITY];
					}
				}
			}
		}

		/// <summary>
		///		Adds the elements of another <c>RelationHRefList</c> to the current <c>RelationHRefList</c>.
		/// </summary>
		/// <param name="x">The <c>RelationHRefList</c> whose elements should be added to the end of the current <c>RelationHRefList</c>.</param>
		/// <returns>The new <see cref="RelationHRefList.Count"/> of the <c>RelationHRefList</c>.</returns>
		public virtual int AddRange(RelationHRefList x)
		{
			if (m_count + x.Count >= m_array.Length)
				EnsureCapacity(m_count + x.Count);
			
			Array.Copy(x.m_array, 0, m_array, m_count, x.Count);
			m_count += x.Count;
			m_version++;

			return m_count;
		}

		/// <summary>
		///		Adds the elements of a object implementing <see cref="System.Collections.ICollection"/> interface to the current <c>RelationHRefList</c>.
		/// </summary>
		/// <param name="c">The <see cref="System.Collections.ICollection"/> array whose elements should be added to the end of the <c>RelationHRefList</c>.</param>
		/// <returns>The new <see cref="RelationHRefList.Count"/> of the <c>RelationHRefList</c>.</returns>
		public virtual int AddRange(System.Collections.ICollection c)
		{
			if (m_count + c.Count >= m_array.Length)
				EnsureCapacity(m_count + c.Count);
			
			c.CopyTo(m_array, m_count);
			m_count += c.Count;
			m_version++;

			return m_count;
		}

		/// <summary>
		///		Adds the elements of a <see cref="string"/> array to the current <c>RelationHRefList</c>.
		/// </summary>
		/// <param name="x">The <see cref="string"/> array whose elements should be added to the end of the <c>RelationHRefList</c>.</param>
		/// <returns>The new <see cref="RelationHRefList.Count"/> of the <c>RelationHRefList</c>.</returns>
		public virtual int AddRange(string[] x)
		{
			if (m_count + x.Length >= m_array.Length)
				EnsureCapacity(m_count + x.Length);

			Array.Copy(x, 0, m_array, m_count, x.Length);
			m_count += x.Length;
			m_version++;

			return m_count;
		}
		
		/// <summary>
		///		Sets the capacity to the actual number of elements.
		/// </summary>
		public virtual void TrimToSize()
		{
			this.Capacity = m_count;
		}

		#endregion

		#region Implementation (helpers)

		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="RelationHRefList.Count"/>.</para>
		/// </exception>
		private void ValidateIndex(int i)
		{
			ValidateIndex(i, false);
		}

		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="RelationHRefList.Count"/>.</para>
		/// </exception>
		private void ValidateIndex(int i, bool allowEqualEnd)
		{
			int max = (allowEqualEnd)?(m_count):(m_count-1);
			if (i < 0 || i > max)
				throw new System.ArgumentOutOfRangeException("Index was out of range.  Must be non-negative and less than the size of the collection.", (object)i, "Specified argument was out of the range of valid values.");
		}

		private void EnsureCapacity(int min)
		{
			int newCapacity = ((m_array.Length == 0) ? DEFAULT_CAPACITY : m_array.Length * 2);
			if (newCapacity < min)
				newCapacity = min;

			this.Capacity = newCapacity;
		}

		#endregion
		
		#region Implementation (ICollection)

		void ICollection.CopyTo(Array array, int start)
		{
			Array.Copy(m_array, 0, array, start, m_count);
		}

		#endregion

		#region Implementation (IList)

		object IList.this[int i]
		{
			get { return (object)this[i]; }
			set { this[i] = (string)value; }
		}

		int IList.Add(object x)
		{
			return this.Add((string)x);
		}

    	bool IList.Contains(object x)
		{
			return this.Contains((string)x);
		}

		int IList.IndexOf(object x)
		{
			return this.IndexOf((string)x);
		}

		void IList.Insert(int pos, object x)
		{
			this.Insert(pos, (string)x);
		}

		void IList.Remove(object x)
		{
			this.Remove((string)x);
		}

		void IList.RemoveAt(int pos)
		{
			this.RemoveAt(pos);
		}

		#endregion

		#region Implementation (IEnumerable)

		IEnumerator IEnumerable.GetEnumerator()
		{
			return (IEnumerator)(this.GetEnumerator());
		}

		#endregion

		#region Nested enumerator class
		/// <summary>
		///		Supports simple iteration over a <see cref="RelationHRefList"/>.
		/// </summary>
		private class Enumerator : IEnumerator, IRelationHRefListEnumerator
		{
			#region Implementation (data)
			
			private RelationHRefList m_collection;
			private int m_index;
			private int m_version;
			
			#endregion
		
			#region Construction
			
			/// <summary>
			///		Initializes a new instance of the <c>Enumerator</c> class.
			/// </summary>
			/// <param name="tc"></param>
			internal Enumerator(RelationHRefList tc)
			{
				m_collection = tc;
				m_index = -1;
				m_version = tc.m_version;
			}
			
			#endregion
	
			#region Operations (type-safe IEnumerator)
			
			/// <summary>
			///		Gets the current element in the collection.
			/// </summary>
			public string Current
			{
				get { return m_collection[m_index]; }
			}

			/// <summary>
			///		Advances the enumerator to the next element in the collection.
			/// </summary>
			/// <exception cref="InvalidOperationException">
			///		The collection was modified after the enumerator was created.
			/// </exception>
			/// <returns>
			///		<c>true</c> if the enumerator was successfully advanced to the next element; 
			///		<c>false</c> if the enumerator has passed the end of the collection.
			/// </returns>
			public bool MoveNext()
			{
				if (m_version != m_collection.m_version)
					throw new System.InvalidOperationException("Collection was modified; enumeration operation may not execute.");

				++m_index;
				return (m_index < m_collection.Count) ? true : false;
			}

			/// <summary>
			///		Sets the enumerator to its initial position, before the first element in the collection.
			/// </summary>
			public void Reset()
			{
				m_index = -1;
			}
			#endregion
	
			#region Implementation (IEnumerator)
			
			object IEnumerator.Current
			{
				get { return (object)(this.Current); }
			}
			
			#endregion
		}
        #endregion
        
        #region Nested Syncronized Wrapper class
        private class SyncRelationHRefList : RelationHRefList
        {
            #region Implementation (data)
            private RelationHRefList m_collection;
            private object m_root;
            #endregion

            #region Construction
            internal SyncRelationHRefList(RelationHRefList list) : base(Tag.Default)
            {
                m_root = list.SyncRoot;
                m_collection = list;
            }
            #endregion
            
            #region Type-safe ICollection
            public override void CopyTo(string[] array)
            {
                lock(this.m_root)
                    m_collection.CopyTo(array);
            }

            public override void CopyTo(string[] array, int start)
            {
                lock(this.m_root)
                    m_collection.CopyTo(array,start);
            }
            public override int Count
            {
                get
                { 
                    lock(this.m_root)
                        return m_collection.Count;
                }
            }

            public override bool IsSynchronized
            {
                get { return true; }
            }

            public override object SyncRoot
            {
                get { return this.m_root; }
            }
            #endregion
            
            #region Type-safe IList
            public override string this[int i]
            {
                get
                {
                    lock(this.m_root)
                        return m_collection[i];
                }
                set
                {
                    lock(this.m_root)
                        m_collection[i] = value; 
                }
            }

            public override int Add(string x)
            {
                lock(this.m_root)
                    return m_collection.Add(x);
            }
            
            public override void Clear()
            {
                lock(this.m_root)
                    m_collection.Clear();
            }

            public override bool Contains(string x)
            {
                lock(this.m_root)
                    return m_collection.Contains(x);
            }

            public override int IndexOf(string x)
            {
                lock(this.m_root)
                    return m_collection.IndexOf(x);
            }

            public override void Insert(int pos, string x)
            {
                lock(this.m_root)
                    m_collection.Insert(pos,x);
            }

            public override void Remove(string x)
            {           
                lock(this.m_root)
                    m_collection.Remove(x);
            }

            public override void RemoveAt(int pos)
            {
                lock(this.m_root)
                    m_collection.RemoveAt(pos);
            }
            
            public override bool IsFixedSize
            {
                get {return m_collection.IsFixedSize;}
            }

            public override bool IsReadOnly
            {
                get {return m_collection.IsReadOnly;}
            }
            #endregion

            #region Type-safe IEnumerable
            public override IRelationHRefListEnumerator GetEnumerator()
            {
                lock(m_root)
                    return m_collection.GetEnumerator();
            }
            #endregion

            #region Public Helpers
            // (just to mimic some nice features of ArrayList)
            public override int Capacity
            {
                get
                {
                    lock(this.m_root)
                        return m_collection.Capacity;
                }
                
                set
                {
                    lock(this.m_root)
                        m_collection.Capacity = value;
                }
            }

            public override int AddRange(RelationHRefList x)
            {
                lock(this.m_root)
                    return m_collection.AddRange(x);
            }

            public override int AddRange(System.Collections.ICollection c)
            {
                lock(this.m_root)
                    return m_collection.AddRange(c);
            }

            public override int AddRange(string[] x)
            {
                lock(this.m_root)
                    return m_collection.AddRange(x);
            }
            #endregion
        }
        #endregion

        #region Nested Read Only Wrapper class
        private class ReadOnlyRelationHRefList : RelationHRefList
        {
            #region Implementation (data)
            private RelationHRefList m_collection;
            #endregion

            #region Construction
            internal ReadOnlyRelationHRefList(RelationHRefList list) : base(Tag.Default)
            {
                m_collection = list;
            }
            #endregion
            
            #region Type-safe ICollection
            public override void CopyTo(string[] array)
            {
                m_collection.CopyTo(array);
            }

            public override void CopyTo(string[] array, int start)
            {
                m_collection.CopyTo(array,start);
            }
            public override int Count
            {
                get {return m_collection.Count;}
            }

            public override bool IsSynchronized
            {
                get { return m_collection.IsSynchronized; }
            }

            public override object SyncRoot
            {
                get { return this.m_collection.SyncRoot; }
            }
            #endregion
            
            #region Type-safe IList
            public override string this[int i]
            {
                get { return m_collection[i]; }
                set { throw new NotSupportedException("This is a Read Only Collection and can not be modified"); }
            }

            public override int Add(string x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }
            
            public override void Clear()
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override bool Contains(string x)
            {
                return m_collection.Contains(x);
            }

            public override int IndexOf(string x)
            {
                return m_collection.IndexOf(x);
            }

            public override void Insert(int pos, string x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override void Remove(string x)
            {           
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override void RemoveAt(int pos)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }
            
            public override bool IsFixedSize
            {
                get {return true;}
            }

            public override bool IsReadOnly
            {
                get {return true;}
            }
            #endregion

            #region Type-safe IEnumerable
            public override IRelationHRefListEnumerator GetEnumerator()
            {
                return m_collection.GetEnumerator();
            }
            #endregion

            #region Public Helpers
            // (just to mimic some nice features of ArrayList)
            public override int Capacity
            {
                get { return m_collection.Capacity; }
                
                set { throw new NotSupportedException("This is a Read Only Collection and can not be modified"); }
            }

            public override int AddRange(RelationHRefList x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override int AddRange(System.Collections.ICollection c)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override int AddRange(string[] x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }
            #endregion
        }
        #endregion
	}

}
	
namespace RssComponents.Collections
{
	

	/// <summary>
	///		A strongly-typed collection of <see cref="RelationBase"/> objects.
	/// </summary>
	[Serializable]
public 
  class RelationList : ICollection, IList, IEnumerable, ICloneable
	{
        #region Interfaces
	    /// <summary>
	    ///		Supports type-safe iteration over a <see cref="RelationList"/>.
	    /// </summary>
        public interface IRelationListEnumerator
        {
		    /// <summary>
		    ///		Gets the current element in the collection.
		    /// </summary>
            RelationBase Current {get;}

		    /// <summary>
		    ///		Advances the enumerator to the next element in the collection.
		    /// </summary>
		    /// <exception cref="InvalidOperationException">
		    ///		The collection was modified after the enumerator was created.
		    /// </exception>
		    /// <returns>
		    ///		<c>true</c> if the enumerator was successfully advanced to the next element; 
		    ///		<c>false</c> if the enumerator has passed the end of the collection.
		    /// </returns>
            bool MoveNext();

		    /// <summary>
		    ///		Sets the enumerator to its initial position, before the first element in the collection.
		    /// </summary>
            void Reset();
        }
        #endregion

		private const int DEFAULT_CAPACITY = 16;

		#region Implementation (data)
		private RelationBase[] m_array;
		private int m_count = 0;
		[NonSerialized]
		private int m_version = 0;
		#endregion
	
        #region Static Wrappers
		/// <summary>
		///		Creates a synchronized (thread-safe) wrapper for a 
		///     <c>RelationList</c> instance.
		/// </summary>
		/// <returns>
		///     An <c>RelationList</c> wrapper that is synchronized (thread-safe).
		/// </returns>
        public static RelationList Synchronized(RelationList list)
        {
            if(list==null)
                throw new ArgumentNullException("list");
            return new SyncRelationList(list);
        }
        
		/// <summary>
		///		Creates a read-only wrapper for a 
		///     <c>RelationList</c> instance.
		/// </summary>
		/// <returns>
		///     An <c>RelationList</c> wrapper that is read-only.
		/// </returns>
        public static RelationList ReadOnly(RelationList list)
        {
            if(list==null)
                throw new ArgumentNullException("list");
            return new ReadOnlyRelationList(list);
        }
        #endregion

	    #region Construction
		/// <summary>
		///		Initializes a new instance of the <c>RelationList</c> class
		///		that is empty and has the default initial capacity.
		/// </summary>
		public RelationList()
		{
			m_array = new RelationBase[DEFAULT_CAPACITY];
		}
		
		/// <summary>
		///		Initializes a new instance of the <c>RelationList</c> class
		///		that has the specified initial capacity.
		/// </summary>
		/// <param name="capacity">
		///		The number of elements that the new <c>RelationList</c> is initially capable of storing.
		///	</param>
		public RelationList(int capacity)
		{
			m_array = new RelationBase[capacity];
		}

		/// <summary>
		///		Initializes a new instance of the <c>RelationList</c> class
		///		that contains elements copied from the specified <c>RelationList</c>.
		/// </summary>
		/// <param name="c">The <c>RelationList</c> whose elements are copied to the new collection.</param>
		public RelationList(RelationList c)
		{
			m_array = new RelationBase[c.Count];
			AddRange(c);
		}

		/// <summary>
		///		Initializes a new instance of the <c>RelationList</c> class
		///		that contains elements copied from the specified <c>System.Collections.ICollection</c>.
		/// </summary>
		/// <param name="c">The <c>System.Collections.ICollection</c> whose elements are copied to the new collection.</param>
		public RelationList(System.Collections.ICollection c)
		{
			m_array = new RelationBase[c.Count];
			AddRange(c);
		}

		/// <summary>
		///		Initializes a new instance of the <c>RelationList</c> class
		///		that contains elements copied from the specified <see cref="RelationBase"/> array.
		/// </summary>
		/// <param name="a">The <see cref="RelationBase"/> array whose elements are copied to the new list.</param>
		public RelationList(RelationBase[] a)
		{
			m_array = new RelationBase[a.Length];
			AddRange(a);
		}
		
        protected enum Tag {
            Default
        }

        protected RelationList(Tag t)
        {
            m_array = null;
        }
		#endregion
		
		#region Operations (type-safe ICollection)
		/// <summary>
		///		Gets the number of elements actually contained in the <c>RelationList</c>.
		/// </summary>
		public virtual int Count
		{
			get { return m_count; }
		}

		/// <summary>
		///		Copies the entire <c>RelationList</c> to a one-dimensional
		///		<see cref="RelationBase"/> array.
		/// </summary>
		/// <param name="array">The one-dimensional <see cref="RelationBase"/> array to copy to.</param>
		public virtual void CopyTo(RelationBase[] array)
		{
			this.CopyTo(array, 0);
		}

		/// <summary>
		///		Copies the entire <c>RelationList</c> to a one-dimensional
		///		<see cref="RelationBase"/> array, starting at the specified index of the target array.
		/// </summary>
		/// <param name="array">The one-dimensional <see cref="RelationBase"/> array to copy to.</param>
		/// <param name="start">The zero-based index in <paramref name="array"/> at which copying begins.</param>
		public virtual void CopyTo(RelationBase[] array, int start)
		{
			if (m_count > array.GetUpperBound(0) + 1 - start)
				throw new System.ArgumentException("Destination array was not long enough.");
			
			Array.Copy(m_array, 0, array, start, m_count); 
		}

		/// <summary>
		///		Gets a value indicating whether access to the collection is synchronized (thread-safe).
		/// </summary>
		/// <returns>true if access to the ICollection is synchronized (thread-safe); otherwise, false.</returns>
        public virtual bool IsSynchronized
        {
            get { return m_array.IsSynchronized; }
        }

        /// <summary>
		///		Gets an object that can be used to synchronize access to the collection.
		/// </summary>
        public virtual object SyncRoot
        {
            get { return m_array.SyncRoot; }
        }
		#endregion
		
		#region Operations (type-safe IList)
		/// <summary>
		///		Gets or sets the <see cref="RelationBase"/> at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index of the element to get or set.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="RelationList.Count"/>.</para>
		/// </exception>
		public virtual RelationBase this[int index]
		{
			get
			{
				ValidateIndex(index); // throws
				return m_array[index]; 
			}
			set
			{
				ValidateIndex(index); // throws
				++m_version; 
				m_array[index] = value; 
			}
		}

		/// <summary>
		///		Adds a <see cref="RelationBase"/> to the end of the <c>RelationList</c>.
		/// </summary>
		/// <param name="item">The <see cref="RelationBase"/> to be added to the end of the <c>RelationList</c>.</param>
		/// <returns>The index at which the value has been added.</returns>
		public virtual int Add(RelationBase item)
		{
			if (m_count == m_array.Length)
				EnsureCapacity(m_count + 1);

			m_array[m_count] = item;
			m_version++;

			return m_count++;
		}
		
		/// <summary>
		///		Removes all elements from the <c>RelationList</c>.
		/// </summary>
		public virtual void Clear()
		{
			++m_version;
			m_array = new RelationBase[DEFAULT_CAPACITY];
			m_count = 0;
		}
		
		/// <summary>
		///		Creates a shallow copy of the <see cref="RelationList"/>.
		/// </summary>
		public virtual object Clone()
		{
			RelationList newColl = new RelationList(m_count);
			Array.Copy(m_array, 0, newColl.m_array, 0, m_count);
			newColl.m_count = m_count;
			newColl.m_version = m_version;

			return newColl;
		}

		/// <summary>
		///		Determines whether a given <see cref="RelationBase"/> is in the <c>RelationList</c>.
		/// </summary>
		/// <param name="item">The <see cref="RelationBase"/> to check for.</param>
		/// <returns><c>true</c> if <paramref name="item"/> is found in the <c>RelationList</c>; otherwise, <c>false</c>.</returns>
		public virtual bool Contains(RelationBase item)
		{
			for (int i=0; i != m_count; ++i)
				if (m_array[i].Equals(item))
					return true;
			return false;
		}

		/// <summary>
		///		Returns the zero-based index of the first occurrence of a <see cref="RelationBase"/>
		///		in the <c>RelationList</c>.
		/// </summary>
		/// <param name="item">The <see cref="RelationBase"/> to locate in the <c>RelationList</c>.</param>
		/// <returns>
		///		The zero-based index of the first occurrence of <paramref name="item"/> 
		///		in the entire <c>RelationList</c>, if found; otherwise, -1.
		///	</returns>
		public virtual int IndexOf(RelationBase item)
		{
			for (int i=0; i != m_count; ++i)
				if (m_array[i].Equals(item))
					return i;
			return -1;
		}

		/// <summary>
		///		Inserts an element into the <c>RelationList</c> at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
		/// <param name="item">The <see cref="RelationBase"/> to insert.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="RelationList.Count"/>.</para>
		/// </exception>
		public virtual void Insert(int index, RelationBase item)
		{
			ValidateIndex(index, true); // throws
			
			if (m_count == m_array.Length)
				EnsureCapacity(m_count + 1);

			if (index < m_count)
			{
				Array.Copy(m_array, index, m_array, index + 1, m_count - index);
			}

			m_array[index] = item;
			m_count++;
			m_version++;
		}

		/// <summary>
		///		Removes the first occurrence of a specific <see cref="RelationBase"/> from the <c>RelationList</c>.
		/// </summary>
		/// <param name="item">The <see cref="RelationBase"/> to remove from the <c>RelationList</c>.</param>
		/// <exception cref="ArgumentException">
		///		The specified <see cref="RelationBase"/> was not found in the <c>RelationList</c>.
		/// </exception>
		public virtual void Remove(RelationBase item)
		{		   
			int i = IndexOf(item);
			if (i < 0)
				throw new System.ArgumentException("Cannot remove the specified item because it was not found in the specified Collection.");
			
			++m_version;
			RemoveAt(i);
		}

		/// <summary>
		///		Removes the element at the specified index of the <c>RelationList</c>.
		/// </summary>
		/// <param name="index">The zero-based index of the element to remove.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="RelationList.Count"/>.</para>
		/// </exception>
		public virtual void RemoveAt(int index)
		{
			ValidateIndex(index); // throws
			
			m_count--;

			if (index < m_count)
			{
				Array.Copy(m_array, index + 1, m_array, index, m_count - index);
			}
			
			// We can't set the deleted entry equal to null, because it might be a value type.
			// Instead, we'll create an empty single-element array of the right type and copy it 
			// over the entry we want to erase.
			RelationBase[] temp = new RelationBase[1];
			Array.Copy(temp, 0, m_array, m_count, 1);
			m_version++;
		}

		/// <summary>
		///		Gets a value indicating whether the collection has a fixed size.
		/// </summary>
		/// <value>true if the collection has a fixed size; otherwise, false. The default is false</value>
        public virtual bool IsFixedSize
        {
            get { return false; }
        }

		/// <summary>
		///		gets a value indicating whether the IList is read-only.
		/// </summary>
		/// <value>true if the collection is read-only; otherwise, false. The default is false</value>
        public virtual bool IsReadOnly
        {
            get { return false; }
        }
		#endregion

		#region Operations (type-safe IEnumerable)
		
		/// <summary>
		///		Returns an enumerator that can iterate through the <c>RelationList</c>.
		/// </summary>
		/// <returns>An <see cref="Enumerator"/> for the entire <c>RelationList</c>.</returns>
		public virtual IRelationListEnumerator GetEnumerator()
		{
			return new Enumerator(this);
		}
		#endregion

		#region Public helpers (just to mimic some nice features of ArrayList)
		
		/// <summary>
		///		Gets or sets the number of elements the <c>RelationList</c> can contain.
		/// </summary>
		public virtual int Capacity
		{
			get { return m_array.Length; }
			
			set
			{
				if (value < m_count)
					value = m_count;

				if (value != m_array.Length)
				{
					if (value > 0)
					{
						RelationBase[] temp = new RelationBase[value];
						Array.Copy(m_array, temp, m_count);
						m_array = temp;
					}
					else
					{
						m_array = new RelationBase[DEFAULT_CAPACITY];
					}
				}
			}
		}

		/// <summary>
		///		Adds the elements of another <c>RelationList</c> to the current <c>RelationList</c>.
		/// </summary>
		/// <param name="x">The <c>RelationList</c> whose elements should be added to the end of the current <c>RelationList</c>.</param>
		/// <returns>The new <see cref="RelationList.Count"/> of the <c>RelationList</c>.</returns>
		public virtual int AddRange(RelationList x)
		{
			if (m_count + x.Count >= m_array.Length)
				EnsureCapacity(m_count + x.Count);
			
			Array.Copy(x.m_array, 0, m_array, m_count, x.Count);
			m_count += x.Count;
			m_version++;

			return m_count;
		}

		/// <summary>
		///		Adds the elements of a object implementing <see cref="System.Collections.ICollection"/> interface to the current <c>RelationList</c>.
		/// </summary>
		/// <param name="c">The <see cref="System.Collections.ICollection"/> array whose elements should be added to the end of the <c>RelationList</c>.</param>
		/// <returns>The new <see cref="RelationList.Count"/> of the <c>RelationList</c>.</returns>
		public virtual int AddRange(System.Collections.ICollection c)
		{
			if (m_count + c.Count >= m_array.Length)
				EnsureCapacity(m_count + c.Count);
			
			c.CopyTo(m_array, m_count);
			m_count += c.Count;
			m_version++;

			return m_count;
		}

		/// <summary>
		///		Adds the elements of a <see cref="RelationBase"/> array to the current <c>RelationList</c>.
		/// </summary>
		/// <param name="x">The <see cref="RelationBase"/> array whose elements should be added to the end of the <c>RelationList</c>.</param>
		/// <returns>The new <see cref="RelationList.Count"/> of the <c>RelationList</c>.</returns>
		public virtual int AddRange(RelationBase[] x)
		{
			if (m_count + x.Length >= m_array.Length)
				EnsureCapacity(m_count + x.Length);

			Array.Copy(x, 0, m_array, m_count, x.Length);
			m_count += x.Length;
			m_version++;

			return m_count;
		}
		
		/// <summary>
		///		Sets the capacity to the actual number of elements.
		/// </summary>
		public virtual void TrimToSize()
		{
			this.Capacity = m_count;
		}

		#endregion

		#region Implementation (helpers)

		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="RelationList.Count"/>.</para>
		/// </exception>
		private void ValidateIndex(int i)
		{
			ValidateIndex(i, false);
		}

		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="RelationList.Count"/>.</para>
		/// </exception>
		private void ValidateIndex(int i, bool allowEqualEnd)
		{
			int max = (allowEqualEnd)?(m_count):(m_count-1);
			if (i < 0 || i > max)
				throw new System.ArgumentOutOfRangeException("Index was out of range.  Must be non-negative and less than the size of the collection.", (object)i, "Specified argument was out of the range of valid values.");
		}

		private void EnsureCapacity(int min)
		{
			int newCapacity = ((m_array.Length == 0) ? DEFAULT_CAPACITY : m_array.Length * 2);
			if (newCapacity < min)
				newCapacity = min;

			this.Capacity = newCapacity;
		}

		#endregion
		
		#region Implementation (ICollection)

		void ICollection.CopyTo(Array array, int start)
		{
			Array.Copy(m_array, 0, array, start, m_count);
		}

		#endregion

		#region Implementation (IList)

		object IList.this[int i]
		{
			get { return (object)this[i]; }
			set { this[i] = (RelationBase)value; }
		}

		int IList.Add(object x)
		{
			return this.Add((RelationBase)x);
		}

    	bool IList.Contains(object x)
		{
			return this.Contains((RelationBase)x);
		}

		int IList.IndexOf(object x)
		{
			return this.IndexOf((RelationBase)x);
		}

		void IList.Insert(int pos, object x)
		{
			this.Insert(pos, (RelationBase)x);
		}

		void IList.Remove(object x)
		{
			this.Remove((RelationBase)x);
		}

		void IList.RemoveAt(int pos)
		{
			this.RemoveAt(pos);
		}

		#endregion

		#region Implementation (IEnumerable)

		IEnumerator IEnumerable.GetEnumerator()
		{
			return (IEnumerator)(this.GetEnumerator());
		}

		#endregion

		#region Nested enumerator class
		/// <summary>
		///		Supports simple iteration over a <see cref="RelationList"/>.
		/// </summary>
		private class Enumerator : IEnumerator, IRelationListEnumerator
		{
			#region Implementation (data)
			
			private RelationList m_collection;
			private int m_index;
			private int m_version;
			
			#endregion
		
			#region Construction
			
			/// <summary>
			///		Initializes a new instance of the <c>Enumerator</c> class.
			/// </summary>
			/// <param name="tc"></param>
			internal Enumerator(RelationList tc)
			{
				m_collection = tc;
				m_index = -1;
				m_version = tc.m_version;
			}
			
			#endregion
	
			#region Operations (type-safe IEnumerator)
			
			/// <summary>
			///		Gets the current element in the collection.
			/// </summary>
			public RelationBase Current
			{
				get { return m_collection[m_index]; }
			}

			/// <summary>
			///		Advances the enumerator to the next element in the collection.
			/// </summary>
			/// <exception cref="InvalidOperationException">
			///		The collection was modified after the enumerator was created.
			/// </exception>
			/// <returns>
			///		<c>true</c> if the enumerator was successfully advanced to the next element; 
			///		<c>false</c> if the enumerator has passed the end of the collection.
			/// </returns>
			public bool MoveNext()
			{
				if (m_version != m_collection.m_version)
					throw new System.InvalidOperationException("Collection was modified; enumeration operation may not execute.");

				++m_index;
				return (m_index < m_collection.Count) ? true : false;
			}

			/// <summary>
			///		Sets the enumerator to its initial position, before the first element in the collection.
			/// </summary>
			public void Reset()
			{
				m_index = -1;
			}
			#endregion
	
			#region Implementation (IEnumerator)
			
			object IEnumerator.Current
			{
				get { return (object)(this.Current); }
			}
			
			#endregion
		}
        #endregion
        
        #region Nested Syncronized Wrapper class
        private class SyncRelationList : RelationList
        {
            #region Implementation (data)
            private RelationList m_collection;
            private object m_root;
            #endregion

            #region Construction
            internal SyncRelationList(RelationList list) : base(Tag.Default)
            {
                m_root = list.SyncRoot;
                m_collection = list;
            }
            #endregion
            
            #region Type-safe ICollection
            public override void CopyTo(RelationBase[] array)
            {
                lock(this.m_root)
                    m_collection.CopyTo(array);
            }

            public override void CopyTo(RelationBase[] array, int start)
            {
                lock(this.m_root)
                    m_collection.CopyTo(array,start);
            }
            public override int Count
            {
                get
                { 
                    lock(this.m_root)
                        return m_collection.Count;
                }
            }

            public override bool IsSynchronized
            {
                get { return true; }
            }

            public override object SyncRoot
            {
                get { return this.m_root; }
            }
            #endregion
            
            #region Type-safe IList
            public override RelationBase this[int i]
            {
                get
                {
                    lock(this.m_root)
                        return m_collection[i];
                }
                set
                {
                    lock(this.m_root)
                        m_collection[i] = value; 
                }
            }

            public override int Add(RelationBase x)
            {
                lock(this.m_root)
                    return m_collection.Add(x);
            }
            
            public override void Clear()
            {
                lock(this.m_root)
                    m_collection.Clear();
            }

            public override bool Contains(RelationBase x)
            {
                lock(this.m_root)
                    return m_collection.Contains(x);
            }

            public override int IndexOf(RelationBase x)
            {
                lock(this.m_root)
                    return m_collection.IndexOf(x);
            }

            public override void Insert(int pos, RelationBase x)
            {
                lock(this.m_root)
                    m_collection.Insert(pos,x);
            }

            public override void Remove(RelationBase x)
            {           
                lock(this.m_root)
                    m_collection.Remove(x);
            }

            public override void RemoveAt(int pos)
            {
                lock(this.m_root)
                    m_collection.RemoveAt(pos);
            }
            
            public override bool IsFixedSize
            {
                get {return m_collection.IsFixedSize;}
            }

            public override bool IsReadOnly
            {
                get {return m_collection.IsReadOnly;}
            }
            #endregion

            #region Type-safe IEnumerable
            public override IRelationListEnumerator GetEnumerator()
            {
                lock(m_root)
                    return m_collection.GetEnumerator();
            }
            #endregion

            #region Public Helpers
            // (just to mimic some nice features of ArrayList)
            public override int Capacity
            {
                get
                {
                    lock(this.m_root)
                        return m_collection.Capacity;
                }
                
                set
                {
                    lock(this.m_root)
                        m_collection.Capacity = value;
                }
            }

            public override int AddRange(RelationList x)
            {
                lock(this.m_root)
                    return m_collection.AddRange(x);
            }

            public override int AddRange(System.Collections.ICollection c)
            {
                lock(this.m_root)
                    return m_collection.AddRange(c);
            }

            public override int AddRange(RelationBase[] x)
            {
                lock(this.m_root)
                    return m_collection.AddRange(x);
            }
            #endregion
        }
        #endregion

        #region Nested Read Only Wrapper class
        private class ReadOnlyRelationList : RelationList
        {
            #region Implementation (data)
            private RelationList m_collection;
            #endregion

            #region Construction
            internal ReadOnlyRelationList(RelationList list) : base(Tag.Default)
            {
                m_collection = list;
            }
            #endregion
            
            #region Type-safe ICollection
            public override void CopyTo(RelationBase[] array)
            {
                m_collection.CopyTo(array);
            }

            public override void CopyTo(RelationBase[] array, int start)
            {
                m_collection.CopyTo(array,start);
            }
            public override int Count
            {
                get {return m_collection.Count;}
            }

            public override bool IsSynchronized
            {
                get { return m_collection.IsSynchronized; }
            }

            public override object SyncRoot
            {
                get { return this.m_collection.SyncRoot; }
            }
            #endregion
            
            #region Type-safe IList
            public override RelationBase this[int i]
            {
                get { return m_collection[i]; }
                set { throw new NotSupportedException("This is a Read Only Collection and can not be modified"); }
            }

            public override int Add(RelationBase x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }
            
            public override void Clear()
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override bool Contains(RelationBase x)
            {
                return m_collection.Contains(x);
            }

            public override int IndexOf(RelationBase x)
            {
                return m_collection.IndexOf(x);
            }

            public override void Insert(int pos, RelationBase x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override void Remove(RelationBase x)
            {           
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override void RemoveAt(int pos)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }
            
            public override bool IsFixedSize
            {
                get {return true;}
            }

            public override bool IsReadOnly
            {
                get {return true;}
            }
            #endregion

            #region Type-safe IEnumerable
            public override IRelationListEnumerator GetEnumerator()
            {
                return m_collection.GetEnumerator();
            }
            #endregion

            #region Public Helpers
            // (just to mimic some nice features of ArrayList)
            public override int Capacity
            {
                get { return m_collection.Capacity; }
                
                set { throw new NotSupportedException("This is a Read Only Collection and can not be modified"); }
            }

            public override int AddRange(RelationList x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override int AddRange(System.Collections.ICollection c)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override int AddRange(RelationBase[] x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }
            #endregion
        }
        #endregion
	}

}
namespace RssComponents.Collections
{
	public 
	class RelationLists : IDictionary, ICollection, IEnumerable, ICloneable
	{
		protected Hashtable innerHash;
		
		#region "Constructors"
		public  RelationLists()
		{
			innerHash = new Hashtable();
		}
		public RelationLists(RelationLists original)
		{
			innerHash = new Hashtable (original.innerHash);
		}
		public RelationLists(IDictionary dictionary)
		{
			innerHash = new Hashtable (dictionary);
		}

		public RelationLists(int capacity)
		{
			innerHash = new Hashtable(capacity);
		}

		public RelationLists(IDictionary dictionary, float loadFactor)
		{
			innerHash = new Hashtable(dictionary, loadFactor);
		}

		public RelationLists(IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (codeProvider, comparer);
		}

		public RelationLists(int capacity, int loadFactor)
		{
			innerHash = new Hashtable(capacity, loadFactor);
		}

		public RelationLists(IDictionary dictionary, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (dictionary, codeProvider, comparer);
		}
		
		public RelationLists(int capacity, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (capacity, codeProvider, comparer);
		}

		public RelationLists(IDictionary dictionary, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (dictionary, loadFactor, codeProvider, comparer);
		}

		public RelationLists(int capacity, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (capacity, loadFactor, codeProvider, comparer);
		}

		
#endregion

		#region Implementation of IDictionary
        public RelationListsEnumerator GetEnumerator()
        {
	        return new RelationListsEnumerator(this);
        }
        
		System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator()
		{
			return new RelationListsEnumerator(this);
		}
		
		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public void Remove(string key)
		{
			innerHash.Remove (key);
		}
		void IDictionary.Remove(object key)
		{
			Remove ((string)key);
		}

		public bool Contains(string key)
		{
			return innerHash.Contains(key);
		}
		bool IDictionary.Contains(object key)
		{
			return Contains((string)key);
		}

		public void Clear()
		{
			innerHash.Clear();		
		}

		public void Add(string key, RelationList value)
		{
			innerHash.Add (key, value);
		}
		void IDictionary.Add(object key, object value)
		{
			Add ((string)key, (RelationList)value);
		}

		public bool IsReadOnly
		{
			get
			{
				return innerHash.IsReadOnly;
			}
		}

		public RelationList this[string key]
		{
			get
			{
				return (RelationList) innerHash[key];
			}
			set
			{
				innerHash[key] = value;
			}
		}
		object IDictionary.this[object key]
		{
			get
			{
				return this[(string)key];
			}
			set
			{
				this[(string)key] = (RelationList)value;
			}
		}
        
		public System.Collections.ICollection Values
		{
			get
			{
				return innerHash.Values;
			}
		}

		public System.Collections.ICollection Keys
		{
			get
			{
				return innerHash.Keys;
			}
		}

		public bool IsFixedSize
		{
			get
			{
				return innerHash.IsFixedSize;
			}
		}
		#endregion

		#region Implementation of ICollection
		public void CopyTo(System.Array array, int index)
		{
			innerHash.CopyTo (array, index);
		}

		public bool IsSynchronized
		{
			get
			{
				return innerHash.IsSynchronized;
			}
		}

		public int Count
		{
			get
			{
				return innerHash.Count;
			}
		}

		public object SyncRoot
		{
			get
			{
				return innerHash.SyncRoot;
			}
		}
		#endregion

		#region Implementation of ICloneable
		public RelationLists Clone()
		{
			RelationLists clone = new RelationLists();
			clone.innerHash = (Hashtable) innerHash.Clone();
			
			return clone;
		}
		object ICloneable.Clone()
		{
			return Clone();
		}
		#endregion
		
		#region "HashTable Methods"
		public bool ContainsKey (string key)
		{
			return innerHash.ContainsKey(key);
		}
		public bool ContainsValue (RelationList value)
		{
			return innerHash.ContainsValue(value);
		}
		public static RelationLists Synchronized(RelationLists nonSync)
		{
			RelationLists sync = new RelationLists();
			sync.innerHash = Hashtable.Synchronized(nonSync.innerHash);

			return sync;
		}
		#endregion

		internal Hashtable InnerHash
		{
			get
			{
				return innerHash;
			}
		}
	}
	
	public class RelationListsEnumerator : IDictionaryEnumerator
	{
		private IDictionaryEnumerator innerEnumerator;
			
		internal RelationListsEnumerator (RelationLists enumerable)
		{
			innerEnumerator = enumerable.InnerHash.GetEnumerator();
		}

		#region Implementation of IDictionaryEnumerator
		public string Key
		{
			get
			{
				return (string)innerEnumerator.Key;
			}
		}
		object IDictionaryEnumerator.Key
		 {
			 get
			 {
				 return Key;
			 }
		 }


		public RelationList Value
		{
			get
			{
				return (RelationList)innerEnumerator.Value;
			}
		}
		object IDictionaryEnumerator.Value
		{
			get
			{
				return Value;
			}
		}

		public System.Collections.DictionaryEntry Entry
		{
			get
			{
				return innerEnumerator.Entry;
			}
		}

		#endregion

		#region Implementation of IEnumerator
		public void Reset()
		{
			innerEnumerator.Reset();
		}

		public bool MoveNext()
		{
			return innerEnumerator.MoveNext();
		}

		public object Current
		{
			get
			{
				return innerEnumerator.Current;
			}
		}
		#endregion
	}

}
	
namespace RssComponents.Collections
{
	public 
	class Relations : IDictionary, ICollection, IEnumerable, ICloneable
	{
		protected Hashtable innerHash;
		
		#region "Constructors"
		public  Relations()
		{
			innerHash = new Hashtable();
		}
		public Relations(Relations original)
		{
			innerHash = new Hashtable (original.innerHash);
		}
		public Relations(IDictionary dictionary)
		{
			innerHash = new Hashtable (dictionary);
		}

		public Relations(int capacity)
		{
			innerHash = new Hashtable(capacity);
		}

		public Relations(IDictionary dictionary, float loadFactor)
		{
			innerHash = new Hashtable(dictionary, loadFactor);
		}

		public Relations(IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (codeProvider, comparer);
		}

		public Relations(int capacity, int loadFactor)
		{
			innerHash = new Hashtable(capacity, loadFactor);
		}

		public Relations(IDictionary dictionary, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (dictionary, codeProvider, comparer);
		}
		
		public Relations(int capacity, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (capacity, codeProvider, comparer);
		}

		public Relations(IDictionary dictionary, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (dictionary, loadFactor, codeProvider, comparer);
		}

		public Relations(int capacity, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (capacity, loadFactor, codeProvider, comparer);
		}

		
#endregion

		#region Implementation of IDictionary
        public RelationsEnumerator GetEnumerator()
        {
	        return new RelationsEnumerator(this);
        }
        
		System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator()
		{
			return new RelationsEnumerator(this);
		}
		
		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public void Remove(string key)
		{
			innerHash.Remove (key);
		}
		void IDictionary.Remove(object key)
		{
			Remove ((string)key);
		}

		public bool Contains(string key)
		{
			return innerHash.Contains(key);
		}
		bool IDictionary.Contains(object key)
		{
			return Contains((string)key);
		}

		public void Clear()
		{
			innerHash.Clear();		
		}

		public void Add(string key, RelationBase value)
		{
			innerHash.Add (key, value);
		}
		void IDictionary.Add(object key, object value)
		{
			Add ((string)key, (RelationBase)value);
		}

		public bool IsReadOnly
		{
			get
			{
				return innerHash.IsReadOnly;
			}
		}

		public RelationBase this[string key]
		{
			get
			{
				return (RelationBase) innerHash[key];
			}
			set
			{
				innerHash[key] = value;
			}
		}
		object IDictionary.this[object key]
		{
			get
			{
				return this[(string)key];
			}
			set
			{
				this[(string)key] = (RelationBase)value;
			}
		}
        
		public System.Collections.ICollection Values
		{
			get
			{
				return innerHash.Values;
			}
		}

		public System.Collections.ICollection Keys
		{
			get
			{
				return innerHash.Keys;
			}
		}

		public bool IsFixedSize
		{
			get
			{
				return innerHash.IsFixedSize;
			}
		}
		#endregion

		#region Implementation of ICollection
		public void CopyTo(System.Array array, int index)
		{
			innerHash.CopyTo (array, index);
		}

		public bool IsSynchronized
		{
			get
			{
				return innerHash.IsSynchronized;
			}
		}

		public int Count
		{
			get
			{
				return innerHash.Count;
			}
		}

		public object SyncRoot
		{
			get
			{
				return innerHash.SyncRoot;
			}
		}
		#endregion

		#region Implementation of ICloneable
		public Relations Clone()
		{
			Relations clone = new Relations();
			clone.innerHash = (Hashtable) innerHash.Clone();
			
			return clone;
		}
		object ICloneable.Clone()
		{
			return Clone();
		}
		#endregion
		
		#region "HashTable Methods"
		public bool ContainsKey (string key)
		{
			return innerHash.ContainsKey(key);
		}
		public bool ContainsValue (RelationBase value)
		{
			return innerHash.ContainsValue(value);
		}
		public static Relations Synchronized(Relations nonSync)
		{
			Relations sync = new Relations();
			sync.innerHash = Hashtable.Synchronized(nonSync.innerHash);

			return sync;
		}
		#endregion

		internal Hashtable InnerHash
		{
			get
			{
				return innerHash;
			}
		}
	}
	
	public class RelationsEnumerator : IDictionaryEnumerator
	{
		private IDictionaryEnumerator innerEnumerator;
			
		internal RelationsEnumerator (Relations enumerable)
		{
			innerEnumerator = enumerable.InnerHash.GetEnumerator();
		}

		#region Implementation of IDictionaryEnumerator
		public string Key
		{
			get
			{
				return (string)innerEnumerator.Key;
			}
		}
		object IDictionaryEnumerator.Key
		 {
			 get
			 {
				 return Key;
			 }
		 }


		public RelationBase Value
		{
			get
			{
				return (RelationBase)innerEnumerator.Value;
			}
		}
		object IDictionaryEnumerator.Value
		{
			get
			{
				return Value;
			}
		}

		public System.Collections.DictionaryEntry Entry
		{
			get
			{
				return innerEnumerator.Entry;
			}
		}

		#endregion

		#region Implementation of IEnumerator
		public void Reset()
		{
			innerEnumerator.Reset();
		}

		public bool MoveNext()
		{
			return innerEnumerator.MoveNext();
		}

		public object Current
		{
			get
			{
				return innerEnumerator.Current;
			}
		}
		#endregion
	}

}
namespace RssComponents.Collections
{
	

	/// <summary>
	///		Represents a strongly-typed collection of key-and-value pairs that are
	///		sorted by the keys and are accessible by key and by index.
	/// </summary>
	/// <seealso cref="System.Collections.SortedList"/>
	[Serializable]
public 
  class SortedRelations : IDictionary, ICloneable
	{
		#region Member Variables
		private const int DEFAULT_CAPACITY = 16;

		private RelationBase[] keys;
		private bool[] values;
		private int count;
		[NonSerialized]
		private int version;
		private IComparer comparer;
		private KeyList keyList;
		private ValueList valueList;
		#endregion

		#region Constructors
		/// <summary>
		///		Initializes a new instance of the <see cref="SortedRelations"/> class that is empty, 
		///		has the default initial capacity and is sorted according to the <see cref="IComparable"/> interface 
		///		implemented by each key added to the <b>SortedRelations</b>.
		/// </summary>
		public SortedRelations()
		{
			keys = new RelationBase[DEFAULT_CAPACITY];
			values = new bool[DEFAULT_CAPACITY];
			comparer = Comparer.Default;
		}

		/// <summary>
		///		Initializes a new instance of the <see cref="SortedRelations"/> class that is empty, 
		///		has the specified initial capacity and is sorted according to the <see cref="IComparable"/>
		///		interface implemented by each key added to the <b>SortedRelations</b>.
		/// </summary>
		/// <param name="capacity">The initial number of elements that the <see cref="SortedRelations"/> can contain.</param>
		/// <exception cref="ArgumentOutOfRangeException"><paramref name="capacity"/> is less than zero.</exception>
		public SortedRelations(int capacity)
		{
			if (capacity < 0)
				throw new ArgumentOutOfRangeException("capacity", capacity, "Initial capacity cannot be less than zero.");

			keys = new RelationBase[capacity];
			values = new bool[capacity];
			comparer = Comparer.Default;
		}

		/// <summary>
		///		Initializes a new instance of the <see cref="SortedRelations"/> class that is empty, 
		///		has the default initial capacity and is sorted according to the specified 
		///		<see cref="IComparer"/> interface.
		/// </summary>
		/// <param name="comparer">
		///		<para>The <see cref="IComparer"/> implementation to use when comparing keys.</para>
		///		<para>-or-</para>
		///		<para>A null reference, to use the <see cref="IComparable"/> implementation of each key.</para>
		/// </param>
		public SortedRelations(IComparer comparer) : this()
		{
			if (comparer != null)
				this.comparer = comparer;
		}

		/// <summary>
		///		Initializes a new instance of the <see cref="SortedRelations"/> class that is empty, 
		///		has the specified initial capacity and is sorted according to the specified 
		///		<see cref="IComparer"/> interface.
		/// </summary>
		/// <param name="comparer">
		///		<para>The <see cref="IComparer"/> implementation to use when comparing keys.</para>
		///		<para>-or-</para>
		///		<para>A null reference, to use the <see cref="IComparable"/> implementation of each key.</para>
		/// </param>
		/// <param name="capacity">The initial number of elements that the <see cref="SortedRelations"/> can contain.</param>
 		/// <exception cref="ArgumentOutOfRangeException"><paramref name="capacity"/> is less than zero.</exception>
		public SortedRelations(IComparer comparer, int capacity) : this(capacity)
		{
			if (comparer != null)
				this.comparer = comparer;
		}

		/// <summary>
		///		Initializes a new instance of the <see cref="SortedRelations"/> class that contains 
		///		elements copied from the specified dictionary, has the same initial capacity as the 
		///		number of elements copied and is sorted according to the <see cref="IComparable"/> interface 
		///		implemented by each key.
		/// </summary>
		/// <param name="d">The <see cref="IDictionary"/> to copy to a new SortedList.</param>
		/// <exception cref="ArgumentNullException"><paramref name="d"/> is a null reference.</exception>
		/// <exception cref="InvalidCastException">
		///		<para>One or more elements in <paramref name="d"/> do not implement the
		///		<see cref="IComparable"/> interface.</para>
		///		<para>-or-</para>
		///		<para><pararef name="d"/> contains elements of a type not supported by <see cref="SortedRelations"/>.</para>
		///	</exception>
		public SortedRelations(IDictionary d) : this(d, null) {}

		/// <summary>
		///		Initializes a new instance of the <see cref="SortedRelations"/> class that contains 
		///		elements copied from the specified dictionary, has the same initial capacity as the 
		///		number of elements copied and is sorted according to the specified <see cref="IComparer"/> interface.
		/// </summary>
		/// <param name="d">The <see cref="IDictionary"/> to copy to a new SortedList.</param>
		/// <param name="comparer">
		///		<para>The <see cref="IComparer"/> implementation to use when comparing keys.</para>
		///		<para>-or-</para>
		///		<para>A null reference, to use the <see cref="IComparable"/> implementation of each key.</para>
		/// </param>
		/// <exception cref="ArgumentNullException"><paramref name="d"/> is a null reference.</exception>
		/// <exception cref="InvalidCastException">
		///		<para>One or more elements in <paramref name="d"/> do not implement the
		///		<see cref="IComparable"/> interface.</para>
		///		<para>-or-</para>
		///		<para><pararef name="d"/> contains elements of a type not supported by <see cref="SortedRelations"/>.</para>
		///	</exception>
		public SortedRelations(IDictionary d, IComparer comparer)
			: this(comparer, (d == null ? 0 : d.Count))
		{
			if (d == null)
				throw new ArgumentNullException("d", "The IDictionary cannot be null.");

			d.Keys.CopyTo(keys, 0);
			d.Values.CopyTo(values, 0);
			Array.Sort(this.keys, this.values, this.comparer);
			this.count = d.Count;
		}
		#endregion

		#region Properties
		/// <summary>
		///		Gets and sets the value associated with a specific key in the <b>SortedRelations</b>.
		/// </summary>
		/// <value>
		///		The <see cref="bool"/> associated with <paramref name="key"/> in the <see cref="SortedRelations"/>,
		///		if <paramref name="key"/> is found; otherwise, a <see cref="NullReferenceException"/> is thrown.
		///	</value>
		/// <remarks>
		///		This property, unlike its equivalent in <see cref="System.Collections.SortedList"/>, does not return
		///		null when a key cannot be found. The reason for this is that the strongly-typed sorted list
		///		template this class is created from allows the value to be a value type (or struct), which cannot
		///		be set to null. Instead, a <see cref="NullReferenceException"/> is thrown when a key cannot be found.
		///		Callers must either catch this exception, or call the <see cref="SortedRelations.Contains"/> method first to
		///		see if the key exists.
		/// </remarks>
		/// <exception cref="ArgumentNullException">The <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="ArgumentException">
		///		Either the <paramref name="key"/> or the <paramref name="value"/> are not of a type supported by the <see cref="SortedRelations"/>.
		/// </exception>
		/// <exception cref="NullReferenceException">
		///		<paramref name="key"/> is not found in the <see cref="SortedRelations"/>.
		/// </exception>
		object IDictionary.this[object key]
		{
			get
			{
				if (key == null)
					throw new ArgumentNullException("key", "The key cannot be null.");

				if (!(key is RelationBase))
					throw new ArgumentException("The key must be of type: " + typeof(RelationBase).FullName, "key");

				return this[(RelationBase)key];
			}
			set
			{
				if (key == null)
					throw new ArgumentNullException("key", "The key cannot be null.");

				if (!(key is RelationBase))
					throw new ArgumentException("The key must be of type: " + typeof(RelationBase).FullName, "key");

				if (!(value is bool))
					throw new ArgumentException("The value must be of type: " + typeof(bool).FullName, "value");

				this[(RelationBase)key] = (bool)value;
			}
		}

		/// <summary>
		///		Gets and sets the value associated with a specific key in the <b>SortedRelations</b>.
		/// </summary>
		/// <value>
		///		The <see cref="bool"/> associated with <paramref name="key"/> in the <see cref="SortedRelations"/>,
		///		if <paramref name="key"/> is found; otherwise, a <see cref="NullReferenceException"/> is thrown.
		///	</value>
		/// <remarks>
		///		<para>This property, unlike its equivalent in <see cref="System.Collections.SortedList"/>, does not return
		///		null when a key cannot be found. The reason for this is that the strongly-typed sorted list
		///		template this class is created from allows the value to be a value type (or struct), which cannot
		///		be set to null. Instead, a <see cref="NullReferenceException"/> is thrown when a key cannot be found.
		///		Callers must either catch this exception, or call the <see cref="SortedRelations.Contains"/> method first to
		///		see if the key exists.</para>
		/// </remarks>
		/// <exception cref="ArgumentNullException">The <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="NullReferenceException">
		///		<paramref name="key"/> is not found in the <see cref="SortedRelations"/>.
		/// </exception>
		public virtual bool this[RelationBase key]
		{
			get
			{
				int index = IndexOfKey(key);
				if (index >= 0)
					return values[index];

				throw new NullReferenceException("The specified key could not be found.");
			}
			set
			{
				if (Object.ReferenceEquals(key, null)) // avoids compiler error for null check on value type
					throw new ArgumentNullException("key", "The key cannot be null.");

				int index = Array.BinarySearch(keys, 0, count, key, comparer);
				if (index >= 0)
				{
					values[index] = value;
					version++;
					return;
				}

				Insert(~index, key, value);
			}
		}

		/// <summary>
		///		Gets or sets the capacity of the <b>SortedRelations</b>.
		/// </summary>
		/// <value>The number of elements that the <see cref="SortedRelations"/> can contain.</value>
		public virtual int Capacity
		{
			get
			{
				return keys.Length;
			}
			set
			{
				if (value < count)
					value = count;

				if (value != keys.Length)
				{
					if (value > 0)
					{
						RelationBase[] newKeys = new RelationBase[value];
						bool[] newValues = new bool[value];

						if (count > 0)
						{
							Array.Copy(keys, 0, newKeys, 0, count);
							Array.Copy(values, 0, newValues, 0, count);
						}
						
						keys = newKeys;
						values = newValues;
					}
					else
					{
						keys = new RelationBase[DEFAULT_CAPACITY];
						values = new bool[DEFAULT_CAPACITY];
					}
				}
			}
		}

		/// <summary>
		///		Gets the number of elements contained in the <b>SortedRelations</b>.
		/// </summary>
		/// <value>The number of elements contained in the <see cref="SortedRelations"/>.</value>
		public virtual int Count
		{
			get
			{
				return this.count;
			}
		}

		/// <summary>
		///		Gets a value indicating whether the <b>SortedRelations</b> has a fixed size.
		/// </summary>
		/// <value>
		///		<b>true</b> if the <see cref="SortedRelations"/> has a fixed size; otherwise, <b>false</b>.
		///		The default is <b>false</b>.
		/// </value>
		public virtual bool IsFixedSize
		{
			get { return false; }
		}

		/// <summary>
		///		Gets a value indicating whether the <b>SortedRelations</b> is read-only.
		/// </summary>
		/// <value>
		///		<b>true</b> if the <see cref="SortedRelations"/> is read-only; otherwise, <b>false</b>.
		///		The default is <b>false</b>.
		/// </value>
		public virtual bool IsReadOnly
		{
			get	{ return false; }
		}

		/// <summary>
		///		Gets a value indicating whether access to the <b>SortedRelations</b> is
		///		synchronized (thread-safe).
		/// </summary>
		/// <value>
		///		<b>true</b> if access to the the <see cref="SortedRelations"/> is 
		///		synchronized (thread-safe); otherwise, <b>false</b>.
		///		The default is <b>false</b>.
		/// </value>
		public virtual bool IsSynchronized
		{
			get { return false; }
		}

		/// <summary>
		///		Gets the keys in the <b>SortedRelations</b>.
		/// </summary>
		/// <value>An <see cref="ICollection"/> containing the keys in the <see cref="SortedRelations"/>.</value>
		/// <remarks>
		///		<para>The <see cref="ICollection"/> is a read-only view of the keys in the 
		///		<see cref="SortedRelations"/>. Modifications made to the underlying <b>SortedRelations</b>
		///		are immediately reflected in the <b>ICollection</b>.</para>
		///		<para>The elements of the <b>ICollection</b> are sorted in the same order as the keys
		///		of the <b>SortedRelations</b>.</para>
		///		<para>Similar to <see cref="SortedRelations.GetKeyList"/>, but returns an <b>ICollection</b>
		///		instead of an <see cref="IList"/>.</para>
		/// </remarks>
		public virtual ICollection Keys
		{
			get
			{
				return GetKeyList();
			}
		}

		/// <summary>
		///		Gets an object that can be used to synchronize access to the <b>SortedRelations</b>.
		/// </summary>
		/// <value>An object that can be used to synchronize access to the <see cref="SortedRelations"/>.</value>
		public virtual object SyncRoot
		{
			get { return this; }
		}

		/// <summary>
		///		Gets the values in the <b>SortedRelations</b>.
		/// </summary>
		/// <value>An <see cref="ICollection"/> containing the values in the <see cref="SortedRelations"/>.</value>
		/// <remarks>
		///		<para>The <see cref="ICollection"/> is a read-only view of the values in the 
		///		<see cref="SortedRelations"/>. Modifications made to the underlying <b>SortedRelations</b>
		///		are immediately reflected in the <b>ICollection</b>.</para>
		///		<para>The elements of the <b>ICollection</b> are sorted in the same order as the values
		///		of the <b>SortedRelations</b>.</para>
		///		<para>Similar to <see cref="SortedRelations.GetValueList"/>, but returns an <b>ICollection</b>
		///		instead of an <see cref="IList"/>.</para>
		/// </remarks>
		public virtual ICollection Values
		{
			get
			{
				return GetValueList();
			}
		}
		#endregion

		#region Public Methods
		/// <summary>
		///		Adds an element with the specified key and value to the <b>SortedRelations</b>.
		/// </summary>
		/// <param name="key">The key of the element to add.</param>
		/// <param name="value">The value of the element to add.</param>
		/// <exception cref="ArgumentNullException">The <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="ArgumentException">
		///		<para>An element with the specified <paramref name="key"/> already exists in the <see cref="SortedRelations"/>.</para>
		///		<para>-or-</para>
		///		<para>Either the <paramref name="key"/> or the <paramref name="value"/> are not of a type supported by the <see cref="SortedRelations"/>.</para>
		///		<para>-or-</para>
		///		<para>The <b>SortedRelations</b> is set to use the <see cref="IComparable"/> interface,
		///		and <paramref name="key"/> does not implement the <b>IComparable</b> interface.</para>
		/// </exception>
		/// <exception cref="InvalidOperationException">The comparer throws an exception.</exception>
		/// <exception cref="NotSupportedException">
		///		<para>The <see cref="SortedRelations"/> is read-only.</para>
		///		<para>-or-</para>
		///		<para>The <b>SortedRelations</b> has a fixed size.</para>
		/// </exception>
		void IDictionary.Add(object key, object value)
		{
			if (key == null)
				throw new ArgumentNullException("key", "The key cannot be null.");

			if (!(key is RelationBase))
				throw new ArgumentException("The key must be of type: " + typeof(RelationBase).FullName, "key");

			if (!(value is bool))
				throw new ArgumentException("The value must be of type: " + typeof(bool).FullName, "value");

			this.Add((RelationBase)key, (bool)value);
		}

		/// <summary>
		///		Adds an element with the specified key and value to the <b>SortedRelations</b>.
		/// </summary>
		/// <param name="key">The key of the element to add.</param>
		/// <param name="value">The value of the element to add.</param>
 		/// <exception cref="ArgumentNullException">The <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="ArgumentException">
		///		<para>An element with the specified <paramref name="key"/> already exists in the <see cref="SortedRelations"/>.</para>
		///		<para>-or-</para>
		///		<para>The <b>SortedRelations</b> is set to use the <see cref="IComparable"/> interface,
		///		and <paramref name="key"/> does not implement the <b>IComparable</b> interface.</para>
		/// </exception>
		/// <exception cref="InvalidOperationException">The comparer throws an exception.</exception>
		/// <exception cref="NotSupportedException">
		///		<para>The <see cref="SortedRelations"/> is read-only.</para>
		///		<para>-or-</para>
		///		<para>The <b>SortedRelations</b> has a fixed size.</para>
		/// </exception>
		public virtual void Add(RelationBase key, bool value)
		{
			if (Object.ReferenceEquals(key, null)) // avoids compiler error for null check on value type
				throw new ArgumentNullException("key", "The key cannot be null.");

			int index = Array.BinarySearch(keys, 0, count, key, comparer);

			if (index >= 0)
				throw new ArgumentException(String.Format("Item has already been added.  Key being added: \"{0}\".", key));
 
			Insert(~index, key, value);
		}

		/// <summary>
		///		Removes all elements from the <b>SortedRelations</b>.
		/// </summary>
		/// <exception cref="NotSupportedException">
		///		<para>The <see cref="SortedRelations"/> is read-only.</para>
		///		<para>-or-</para>
		///		<para>The <b>SortedRelations</b> has a fixed size.</para>
		/// </exception>
		public virtual void Clear()
		{
			keys = new RelationBase[DEFAULT_CAPACITY];
			values = new bool[DEFAULT_CAPACITY];
			count = 0;
			version++;
		}

		/// <summary>
		///		Creates a shallow copy of the <b>SortedRelations</b>.
		/// </summary>
		/// <returns>A shallow copy of the <see cref="SortedRelations"/>.</returns>
		public virtual object Clone()
		{
			SortedRelations newList = new SortedRelations(count);
			Array.Copy(keys, 0, newList.keys, 0, count);
			Array.Copy(values, 0, newList.values, 0, count);
			newList.count = count;
			newList.version = version;
			newList.comparer = comparer;

			return newList;
		}

		/// <summary>
		///		Determines whether the <b>SortedRelations</b> contains a specific key.
		/// </summary>
		/// <param name="key">The key to locate in the <see cref="SortedRelations"/>.</param>
		/// <exception cref="ArgumentNullException">The <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="ArgumentException">
		///		The <paramref name="key"/> is not of a type supported by the <see cref="SortedRelations"/>.
		/// </exception>
		/// <exception cref="InvalidOperationException">The comparer throws an exception.</exception>
		/// <returns>
		///		<b>true</b> if the <see cref="SortedRelations"/> contains an element with the specified key; 
		///		otherwise, <b>false</b>.
		///	</returns>
		bool IDictionary.Contains(object key)
		{
			if (key == null)
				throw new ArgumentNullException("key", "The key cannot be null.");

			if (!(key is RelationBase))
				throw new ArgumentException("The key must be of type: " + typeof(RelationBase).FullName, "key");

			return (IndexOfKey((RelationBase)key) >= 0);
		}

		/// <summary>
		///		Determines whether the <b>SortedRelations</b> contains a specific key.
		/// </summary>
		/// <param name="key">The key to locate in the <see cref="SortedRelations"/>.</param>
		/// <exception cref="ArgumentNullException">The <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="InvalidOperationException">The comparer throws an exception.</exception>
		/// <returns>
		///		<b>true</b> if the <see cref="SortedRelations"/> contains an element with the specified 
		///		<paramref name="key"/>; otherwise, <b>false</b>.
		///	</returns>
		public virtual bool Contains(RelationBase key)
		{
			return (IndexOfKey(key) >= 0);
		}

		/// <summary>
		///		Determines whether the <b>SortedRelations</b> contains a specific key.
		/// </summary>
		/// <param name="key">The key to locate in the <see cref="SortedRelations"/>.</param>
		/// <exception cref="ArgumentNullException">The <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="InvalidOperationException">The comparer throws an exception.</exception>
		/// <returns>
		///		<b>true</b> if the <see cref="SortedRelations"/> contains an element with the specified 
		///		<paramref name="key"/>; otherwise, <b>false</b>.
		///	</returns>
		public virtual bool ContainsKey(RelationBase key)
		{
			return (IndexOfKey(key) >= 0);
		}

		/// <summary>
		///		Determines whether the <b>SortedRelations</b> contains a specific value.
		/// </summary>
		/// <param name="value">The value to locate in the <see cref="SortedRelations"/>.</param>
		/// <returns>
		///		<b>true</b> if the <see cref="SortedRelations"/> contains an element with the specified 
		///		<paramref name="value"/>; otherwise, <b>false</b>.
		/// </returns>
		public virtual bool ContainsValue(bool value)
		{
			return (IndexOfValue(value) >= 0);
		}

		/// <summary>
		///		Copies the <see cref="SortedRelations"/> elements to a one-dimensional <see cref="System.Array"/>
		///		instance at the specified index.
		/// </summary>
		/// <param name="array">
		///		The one-dimensional <see cref="System.Array"/> that is the destination of the
		///		<see cref="DictionaryEntry"/> objects copied from <see cref="SortedRelations"/>.
		///		The array must have zero-based indexing.
		/// </param>
		/// <param name="arrayIndex">The zero-based index in <paramref name="array"/> at which copying begins.</param>
		/// <exception cref="ArgumentNullException"><paramref name="array"/> is a null reference.</exception>
		/// <exception cref="ArgumentOutOfRangeException"><paramref name="arrayIndex"/> is less than zero.</exception>
		/// <exception cref="ArgumentException">
		///		<para><paramref name="array"/> is multidimensional.</para>
		///		<para>-or-</para>
		///		<para><paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.</para>
		///		<para>-or-</para>
		///		<para>The number of elements in the source <see cref="SortedRelations"/> is greater than the 
		///		available space from <paramref name="arrayIndex"/> to the end of the destination <paramref name="array"/>.</para>
		/// </exception>
		/// <exception cref="InvalidCastException">
		///		The type of the source <see cref="SortedRelations"/> cannot be cast automatically to the type
		///		of the destination <paramref name="array"/>.
		/// </exception>
		public virtual void CopyTo(Array array, int arrayIndex)
		{
			if (array == null)
				throw new ArgumentNullException("array", "The destination array cannot be null.");
			if (arrayIndex < 0)
				throw new ArgumentOutOfRangeException("arrayIndex", "Destination index cannot be less than zero.");
			if (array.Rank != 1)
				throw new ArgumentException("Multidimensional arrays are not supported.", "array");
			if (arrayIndex >= array.Length)
				throw new ArgumentException("Destination index cannot be greater than the size of the destination array.", "arrayIndex");
			if (count > (array.Length - arrayIndex))
				throw new ArgumentException("Not enough available space in the destination array.");

			for (int i=0; i < count; i++)
			{
				DictionaryEntry entry = new DictionaryEntry(keys[i], values[i]);
				array.SetValue(entry, arrayIndex + i);
			}
		}

		/// <summary>
		///		Gets the value at the specified index of the <b>SortedRelations</b>.
		/// </summary>
		/// <param name="index">The zero-based index of the value to get.</param>
		/// <returns>The value at the specified index of the <see cref="SortedRelations"/>.</returns>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<paramref name="index"/> is outside the range of valid indices for the <see cref="SortedRelations"/>.
		/// </exception>
		public virtual bool GetByIndex(int index)
		{
			if (index < 0 || index >= count)
				throw new ArgumentOutOfRangeException("index", index, "The index is outside the range of valid indices.");

			return values[index];
		}

		/// <summary>
		///		Returns an <see cref="IEnumerator"/> that can iterate through the <b>SortedRelations</b>.
		/// </summary>
		IEnumerator IEnumerable.GetEnumerator()
		{
			return new SortedListEnumerator(this, 0, count, SortedListEnumerator.DictEntry);
		}

		/// <summary>
		///		Returns an <see cref="IDictionaryEnumerator"/> that can iterate through the
		///		<b>SortedRelations</b>.		
		/// </summary>
		/// <returns>An <see cref="IDictionaryEnumerator"/> for the <see cref="SortedRelations"/>.</returns>
		public virtual IDictionaryEnumerator GetEnumerator()
		{
			return new SortedListEnumerator(this, 0, count, SortedListEnumerator.DictEntry);
		}

		/// <summary>
		///		Gets the key at the specified index of the <b>SortedRelations</b>.
		/// </summary>
		/// <param name="index">The zero-based index of the key to get.</param>
		/// <returns>The key at the specified index of the <see cref="SortedRelations"/>.</returns>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<paramref name="index"/> is outside the range of valid indices for the <see cref="SortedRelations"/>.
		/// </exception>
		public virtual RelationBase GetKey(int index)
		{
			if (index < 0 || index >= count)
				throw new ArgumentOutOfRangeException("index", index, "The index is outside the range of valid indices.");

			return keys[index];
		}

		/// <summary>
		///		Gets the keys in the <b>SortedRelations</b>.
		/// </summary>
		/// <returns>An <see cref="IList"/> containing the keys in the <see cref="SortedRelations"/>.</returns>
		/// <remarks>
		///		<para>The returned <see cref="IList"/> is a read-only view of the keys in the 
		///		<see cref="SortedRelations"/>. Modifications made to the underlying <b>SortedRelations</b>
		///		are immediately reflected in the <b>IList</b>.</para>
		///		<para>The elements of the <b>IList</b> are sorted in the same order as the keys
		///		of the <b>SortedRelations</b>.</para>
		///		<para>Similar to <see cref="SortedRelations.Keys"/>, but returns an <b>IList</b>
		///		instead of an <see cref="ICollection"/>.</para>
		/// </remarks>
		public virtual IList GetKeyList()
		{
			if (keyList == null)
				keyList = new KeyList(this);

			return keyList;
		}

		/// <summary>
		///		Gets the values in the <b>SortedRelations</b>.
		/// </summary>
		/// <returns>An <see cref="IList"/> containing the values in the <see cref="SortedRelations"/>.</returns>
		/// <remarks>
		///		<para>The returned <see cref="IList"/> is a read-only view of the values in the 
		///		<see cref="SortedRelations"/>. Modifications made to the underlying <b>SortedRelations</b>
		///		are immediately reflected in the <b>IList</b>.</para>
		///		<para>The elements of the <b>IList</b> are sorted in the same order as the values
		///		of the <b>SortedRelations</b>.</para>
		///		<para>Similar to <see cref="SortedRelations.Values"/>, but returns an <b>IList</b>
		///		instead of an <see cref="ICollection"/>.</para>
		/// </remarks>
		public virtual IList GetValueList()
		{
			if (valueList == null)
				valueList = new ValueList(this);

			return valueList;
		}

		/// <summary>
		///		Returns the zero-based index of the specified key in the <b>SortedRelations</b>.
		/// </summary>
		/// <param name="key">The key to locate in the <see cref="SortedRelations"/>.</param>
		/// <returns>
		///		The zero-based index of <paramref name="key"/>, if <paramref name="key"/> is found in
		///		the <see cref="SortedRelations"/>; otherwise, -1.
		/// </returns>
		/// <exception cref="ArgumentNullException"><paramref name="key"/> is a null reference.</exception>
		/// <exception cref="InvalidOperationException">The comparer throws an exception.</exception>
		/// <remarks>
		///		<para>The elements of a <see cref="SortedRelations"/> are sorted by the keys either 
		///		according to a specific <see cref="IComparer"/> implementation specified when the 
		///		<see cref="SortedRelations"/> is created or according to the <see cref="IComparable"/> 
		///		implementation provided by the keys themselves.</para>
		///		<para>The index sequence is based on the sort sequence. When an element is added, 
		///		it is inserted into <see cref="SortedRelations"/> in the correct sort order, and the 
		///		indexing adjusts accordingly. When an element removed, the indexing also adjusts accordingly.
		///		Therefore, the index of a specific key-and-value pair might change as elements are added or 
		///		removed from the <see cref="SortedRelations"/>.</para>
		///		<para>This method uses a binary search algorithm; therefore, the average execution time is 
		///		proportional to Log2(<i>n</i>), where <i>n</i> is <see cref="SortedRelations.Count"/>.</para>
		/// </remarks>
		public virtual int IndexOfKey(RelationBase key)
		{
			if (Object.ReferenceEquals(key, null)) // avoids compiler error for null check on value type
				throw new ArgumentNullException("key", "The key cannot be null.");

			int index = Array.BinarySearch(keys, 0, count, key, comparer);

			return (index >= 0 ? index : -1);
		}

		/// <summary>
		///		Returns the zero-based index of the first occurrence of the specified value in
		///		the <b>SortedRelations</b>.
		/// </summary>
		/// <param name="value">The value to locate in the <see cref="SortedRelations"/>.</param>
		/// <returns>
		///		The zero-based index of <paramref name="value"/>, if <paramref name="value"/> is found in
		///		the <see cref="SortedRelations"/>; otherwise, -1.
		/// </returns>
		/// <remarks>
		///		<para>The index sequence is based on the sort sequence. When an element is added, 
		///		it is inserted into <see cref="SortedRelations"/> in the correct sort order, and 
		///		the indexing adjusts accordingly. When an element removed, the indexing also adjusts 
		///		accordingly. Therefore, the index of a specific key-and-value pair might change as 
		///		elements are added or removed from the <see cref="SortedRelations"/>.</para>
		///		<para>The values of the elements of the <see cref="SortedRelations"/> are compared to the 
		///		specified value using the Equals method.</para>
		///		<para>This method uses a linear search; therefore, the average execution time is 
		///		proportional to <see cref="SortedRelations.Count"/>.</para>
		/// </remarks>
		public virtual int IndexOfValue(bool value)
		{
			return Array.IndexOf(values, value, 0, count);
		}

		/// <summary>
		///		Removes the element with the specified key from the <b>SortedRelations</b>.
		/// </summary>
		/// <param name="key">The key of the element to remove.</param>
		/// <exception cref="ArgumentException">
		///		The <paramref name="key"/> is not of a type supported by the <see cref="SortedRelations"/>.
		/// </exception>
		/// <exception cref="ArgumentNullException"><paramref name="key"/> is a null reference.</exception>
		/// <exception cref="NotSupportedException">
		///		<para>The <see cref="SortedRelations"/> is read-only.</para>
		///		<para>-or-</para>
		///		<para>The <b>SortedRelations</b> has a fixed size.</para>
		/// </exception>
		void IDictionary.Remove(object key)
		{
			if (key == null)
				throw new ArgumentNullException("key", "The key cannot be null.");

			if (!(key is RelationBase))
				throw new ArgumentException("The key must be of type: " + typeof(RelationBase).FullName, "key");

			Remove((RelationBase)key);
		}

		/// <summary>
		///		Removes the element with the specified key from the <b>SortedRelations</b>.
		/// </summary>
		/// <param name="key">The key of the element to remove.</param>
		/// <exception cref="ArgumentNullException"><paramref name="key"/> is a null reference.</exception>
		/// <exception cref="NotSupportedException">
		///		<para>The <see cref="SortedRelations"/> is read-only.</para>
		///		<para>-or-</para>
		///		<para>The <b>SortedRelations</b> has a fixed size.</para>
		/// </exception>
		/// <remarks>
		///		If the <see cref="SortedRelations"/> does not contain an element with the specified key,
		///		the <b>SortedRelations</b> remains unchanged. No exception is thrown.
		/// </remarks>
		public virtual void Remove(RelationBase key)
		{
			if (Object.ReferenceEquals(key, null)) // avoids compiler error for null check on value type
				throw new ArgumentNullException("key", "The key cannot be null.");

			int index = IndexOfKey(key);
			if (index >= 0)
				RemoveAt(index);
		}

		/// <summary>
		///		Removes the element at the specified index of the <b>SortedRelations</b>.
		/// </summary>
		/// <param name="index">The zero-based index of the element to remove.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<paramref name="index"/> is outside the range of valid indices for the <see cref="SortedRelations"/>.
		///	</exception>
		/// <exception cref="NotSupportedException">
		///		<para>The <see cref="SortedRelations"/> is read-only.</para>
		///		<para>-or-</para>
		///		<para>The <b>SortedRelations</b> has a fixed size.</para>
		/// </exception>
		/// <remarks>
		///		<para>The index sequence is based on the sort sequence. When an element is added, 
		///		it is inserted into <see cref="SortedRelations"/> in the correct sort order, and 
		///		the indexing adjusts accordingly. When an element removed, the indexing also adjusts 
		///		accordingly. Therefore, the index of a specific key-and-value pair might change as 
		///		elements are added or removed from the <see cref="SortedRelations"/>.</para>
		///		<para>In collections of contiguous elements, such as lists, the elements that
		///		follow the removed element move up to occupy the vacated spot. If the collection is
		///		indexed, the indices of the elements that are moved are also updated.</para>
		/// </remarks>
		public virtual void RemoveAt(int index)
		{
			if (index < 0 || index >= count)
				throw new ArgumentOutOfRangeException("index", index, "The index is outside the range of valid indices.");

			count--;
			if (index < count)
			{
				Array.Copy(keys, index + 1, keys, index, count - index);
				Array.Copy(values, index + 1, values, index, count - index);
			}

			// We can't set the deleted entries equal to null, because they might be value types.
			// Instead, we'll create empty single-element arrays of the right type and copy them 
			// over the entries we want to erase.
			RelationBase[] tempKey = new RelationBase[1];
			bool[] tempVal = new bool[1];
			Array.Copy(tempKey, 0, keys, count, 1);
			Array.Copy(tempVal, 0, values, count, 1);

			version++;
		}

		/// <summary>
		///		Replaces the value at a specific index in the <b>SortedRelations</b>.
		/// </summary>
		/// <param name="index">The zero-based index at which to save <paramref name="value"/>.</param>
		/// <param name="value">The <see cref="bool"/> to save into the <see cref="SortedRelations"/>.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<paramref name="index"/> is outside the range of valid indices for the <see cref="SortedRelations"/>.
		/// </exception>
		/// <remarks>
		///		<para>The index sequence is based on the sort sequence. When an element is added, 
		///		it is inserted into <see cref="SortedRelations"/> in the correct sort order, and 
		///		the indexing adjusts accordingly. When an element removed, the indexing also adjusts 
		///		accordingly. Therefore, the index of a specific key-and-value pair might change as 
		///		elements are added or removed from the <see cref="SortedRelations"/>.</para>
		/// </remarks>
		public virtual void SetByIndex(int index, bool value)
		{
			if (index < 0 || index >= count)
				throw new ArgumentOutOfRangeException("index", index, "The index is outside the range of valid indices.");

			values[index] = value;
			version++;
		}

		/// <summary>
		///		Returns a synchronized (thread-safe) wrapper for the <b>SortedRelations</b>.
		/// </summary>
		/// <param name="list">The <see cref="SortedRelations"/> to synchronize.</param>
		/// <returns>A synchronized (thread-safe) wrapper for the <see cref="SortedRelations"/>.</returns>
		/// <exception cref="ArgumentNullException"><paramref name="list"/> is a null reference.</exception>
		public static SortedRelations Synchronized(SortedRelations list)
		{
			if (list == null)
				throw new ArgumentNullException("list", "The list cannot be null.");

			return new SyncSortedList(list);
		}
		
		/// <summary>
		///		Sets the capacity to the actual number of elements in the <b>SortedRelations</b>.
		/// </summary>
		/// <exception cref="NotSupportedException">
		///		<para>The <see cref="SortedRelations"/> is read-only.</para>
		///		<para>-or-</para>
		///		<para>The <b>SortedRelations</b> has a fixed size.</para>
		/// </exception>
		public virtual void TrimToSize()
		{
			this.Capacity = count;
		}
		#endregion

		#region Private Methods
		private void Insert(int index, RelationBase key, bool value)
		{
			if (count == keys.Length)
				EnsureCapacity(count + 1);

			if (index < count)
			{
				Array.Copy(keys, index, keys, index + 1, count - index);
				Array.Copy(values, index, values, index + 1, count - index);
			}

			keys[index] = key;
			values[index] = value;
			count++;
			version++;
		}

		private void EnsureCapacity(int min)
		{
			int newCapacity = ((keys.Length == 0) ? DEFAULT_CAPACITY : keys.Length * 2);
			if (newCapacity < min)
				newCapacity = min;

			this.Capacity = newCapacity;
		}
		#endregion

		#region Nested Class: SyncSortedList
		[Serializable]
		private class SyncSortedList : SortedRelations, IDictionary
		{
			private SortedRelations list;
			private object root;

			internal SyncSortedList(SortedRelations list)
			{
				this.list = list;
				this.root = list.SyncRoot;
			}

			public override int Capacity
			{
				get
				{
					lock (root)
						return list.Capacity;
				}
			}

			public override int Count
			{
				get
				{
					lock (root)
						return list.Count;
				}
			}

			public override bool IsFixedSize
			{
				get
				{
					return list.IsFixedSize;
				}
			}

			public override bool IsReadOnly
			{
				get
				{
					return list.IsReadOnly;
				}
			}

			public override bool IsSynchronized
			{
				get
				{
					return true;
				}
			}

			public override object SyncRoot
			{
				get
				{
					return root;
				}
			}

			object IDictionary.this[object key]
			{
				get
				{
					lock (root)
						return ((IDictionary)list)[key];
				}
				set
				{
					lock (root)
						((IDictionary)list)[key] = value;
				}
			}

			public override bool this[RelationBase key]
			{
				get
				{
					lock (root)
						return list[key];
				}
				set
				{
					lock (root)
						list[key] = value;
				}
			}

			void IDictionary.Add(object key, object value)
			{
				lock (root)
					((IDictionary)list).Add(key, value);
			}

			public override void Add(RelationBase key, bool value)
			{
				lock (root)
					list.Add(key, value);
			}

			public override void Clear()
			{
				lock (root)
					list.Clear();
			}

			public override object Clone()
			{
				lock (root)
					return list.Clone();
			}

			bool IDictionary.Contains(object key)
			{
				lock (root)
					return ((IDictionary)list).Contains(key);
			}

			public override bool Contains(RelationBase key)
			{
				lock (root)
					return list.Contains(key);
			}

			public override bool ContainsKey(RelationBase key)
			{
				lock (root)
					return list.ContainsKey(key);
			}

			public override bool ContainsValue(bool value)
			{
				lock (root)
					return list.ContainsValue(value);
			}

			public override void CopyTo(Array array, int index)
			{
				lock (root)
					list.CopyTo(array, index);
			}

			public override bool GetByIndex(int index)
			{
				lock (root)
					return list.GetByIndex(index);
			}

			public override IDictionaryEnumerator GetEnumerator()
			{
				lock (root)
					return list.GetEnumerator();
			}

			public override RelationBase GetKey(int index)
			{
				lock (root)
					return list.GetKey(index);
			}

			public override IList GetKeyList()
			{
				lock (root)
					return list.GetKeyList();
			}

			public override IList GetValueList()
			{
				lock (root)
					return list.GetValueList();
			}

			public override int IndexOfKey(RelationBase key)
			{
				lock (root)
					return list.IndexOfKey(key);
			}

			public override int IndexOfValue(bool value)
			{
				lock (root)
					return list.IndexOfValue(value);
			}

			void IDictionary.Remove(object key)
			{
				lock (root)
					((IDictionary)list).Remove(key);
			}

			public override void Remove(RelationBase key)
			{
				lock (root)
					list.Remove(key);
			}

			public override void RemoveAt(int index)
			{
				lock (root)
					list.RemoveAt(index);
			}

			public override void SetByIndex(int index, bool value)
			{
				lock (root)
					list.SetByIndex(index, value);
			}

			public override void TrimToSize()
			{
				lock (root)
					list.TrimToSize();
			}
		}
		#endregion

		#region Nested Class: SortedListEnumerator
		[Serializable]
		private class SortedListEnumerator : IDictionaryEnumerator, ICloneable
		{
			private SortedRelations list;
			private RelationBase key;
			private bool value;
			private int index;
			private int startIndex;
			private int endIndex;
			private int version;
			private bool currentValid;
			private int returnType;

			internal const int Keys = 1;
			internal const int Values = 2;
			internal const int DictEntry = 3;

			internal SortedListEnumerator(SortedRelations list, int index, int count, int returnType)
			{
				this.list = list;
				this.index = index;
				this.startIndex = index;
				this.endIndex = index + count;
				this.version = list.version;
				this.returnType = returnType;
				this.currentValid = false;
			}

			public object Clone()
			{
				return this.MemberwiseClone();
			}

			object IDictionaryEnumerator.Key
			{
				get
				{
					CheckState();
					return key;
				}
			}

			public virtual RelationBase Key
			{
				get
				{
					CheckState();
					return key;
				}
			}

			public virtual DictionaryEntry Entry
			{
				get
				{
					CheckState();
					return new DictionaryEntry(key, value);
				}
			}

			public virtual object Current
			{
				get
				{
					CheckState();

					switch (returnType)
					{
						case Keys:
							return key;
						case Values:
							return value;
						case DictEntry:
						default:
							return new DictionaryEntry(key, value);
					}
				}
			}

			object IDictionaryEnumerator.Value
			{
				get
				{
					CheckState();
					return value;
				}
			}

			public virtual bool Value
			{
				get
				{
					CheckState();
					return value;
				}
			}

			public virtual bool MoveNext()
			{
				if (version != list.version)
					throw new InvalidOperationException("The collection was modified - enumeration cannot continue.");
				
				if (index < endIndex)
				{
					key = list.keys[index];
					value = list.values[index];
					index++;
					currentValid = true;
					return true;
				}

				// We can't set the entries equal to null, because they might be value types.
				// Instead, we'll create empty single-element arrays of the right type and copy them 
				// over the entries we want to erase.
				RelationBase[] tempKey = new RelationBase[1];
				bool[] tempVal = new bool[1];
				key = tempKey[0];
				value = tempVal[0];
				currentValid = false;
				return false;
			}

			public virtual void Reset()
			{
				if (version != list.version)
					throw new InvalidOperationException("The collection was modified - enumeration cannot continue.");

				// We can't set the entries equal to null, because they might be value types.
				// Instead, we'll create empty single-element arrays of the right type and copy them 
				// over the entries we want to erase.
				RelationBase[] tempKey = new RelationBase[1];
				bool[] tempVal = new bool[1];
				key = tempKey[0];
				value = tempVal[0];
				currentValid = false;
				index = startIndex;
			}

			private void CheckState()
			{
				if (version != list.version)
					throw new InvalidOperationException("The collection was modified - enumeration cannot continue.");
				if (!currentValid)
					throw new InvalidOperationException("Enumeration either has not started or has already finished.");
			}
		}
		#endregion

		#region Nested Class: KeyList
		[Serializable]
		private class KeyList : IList
		{
			private SortedRelations list;

			internal KeyList(SortedRelations list)
			{
				this.list = list;
			}

			public virtual int Count
			{
				get
				{
					return list.Count;
				}
			}

			public virtual bool IsReadOnly
			{
				get { return true; }
			}

			public virtual bool IsFixedSize
			{
				get { return true; }
			}

			public virtual bool IsSynchronized
			{
				get { return list.IsSynchronized; }
			}

			public virtual object SyncRoot
			{
				get { return list.SyncRoot; }
			}

			public virtual int Add(object key)
			{
				throw new NotSupportedException("Cannot add to a read-only list.");
			}

			public virtual void Clear()
			{
				throw new NotSupportedException("Cannot clear a read-only list.");
			}

			bool IList.Contains(object key)
			{
				return ((IDictionary)list).Contains(key);
			}

			public virtual bool Contains(RelationBase key)
			{
				return list.Contains(key);
			}

			public virtual void CopyTo(Array array, int index)
			{
				if (array != null && array.Rank != 1)
					throw new ArgumentException("Multidimensional arrays are not supported.", "array");

				Array.Copy(list.keys, 0, array, index, list.Count);
			}

			public virtual void Insert(int index, object value)
			{
				throw new NotSupportedException("Cannot insert into a read-only list.");
			}

			object IList.this[int index]
			{
				get
				{
					return list.GetKey(index);
				}
				set
				{
					throw new NotSupportedException("Cannot modify a read-only list.");
				}
			}

			public virtual RelationBase this[int index]
			{
				get
				{
					return list.GetKey(index);
				}
				set
				{
					throw new NotSupportedException("Cannot modify a read-only list.");
				}
			}

			public virtual IEnumerator GetEnumerator()
			{
				return new SortedListEnumerator(list, 0, list.Count, SortedListEnumerator.Keys);
			}

			int IList.IndexOf(object key)
			{
				if (!(key is RelationBase))
					throw new ArgumentException("The key must be of type: " + typeof(RelationBase).FullName, "key");

				return list.IndexOfKey((RelationBase)key);
			}

			public virtual int IndexOf(RelationBase key)
			{
				return list.IndexOfKey(key);
			}

			public virtual void Remove(object key)
			{
				throw new NotSupportedException("Cannot modify a read-only list.");
			}

			public virtual void RemoveAt(int index)
			{
				throw new NotSupportedException("Cannot modify a read-only list.");
			}
		}
		#endregion

		#region Nested Class: ValueList
		[Serializable]
		private class ValueList : IList
		{
			private SortedRelations list;

			internal ValueList(SortedRelations list)
			{
				this.list = list;
			}

			public virtual int Count
			{
				get
				{
					return list.Count;
				}
			}

			public virtual bool IsReadOnly
			{
				get { return true; }
			}

			public virtual bool IsFixedSize
			{
				get { return true; }
			}

			public virtual bool IsSynchronized
			{
				get { return list.IsSynchronized; }
			}

			public virtual object SyncRoot
			{
				get { return list.SyncRoot; }
			}

			public virtual int Add(object key)
			{
				throw new NotSupportedException("Cannot add to a read-only list.");
			}

			public virtual void Clear()
			{
				throw new NotSupportedException("Cannot clear a read-only list.");
			}

			bool IList.Contains(object value)
			{
				if (!(value is bool))
					throw new ArgumentException("The value must be of type: " + typeof(bool).FullName, "value");

				return list.ContainsValue((bool)value);
			}

			public virtual bool Contains(bool value)
			{
				return list.ContainsValue(value);
			}

			public virtual void CopyTo(Array array, int index)
			{
				if (array != null && array.Rank != 1)
					throw new ArgumentException("Multidimensional arrays are not supported.", "array");

				Array.Copy(list.values, 0, array, index, list.Count);
			}

			public virtual void Insert(int index, object value)
			{
				throw new NotSupportedException("Cannot insert into a read-only list.");
			}

			object IList.this[int index]
			{
				get
				{
					return list.GetByIndex(index);
				}
				set
				{
					if (!(value is bool))
						throw new ArgumentException("The value must be of type: " + typeof(bool).FullName, "value");

					list.SetByIndex(index, (bool)value);
				}
			}

			public virtual bool this[int index]
			{
				get
				{
					return list.GetByIndex(index);
				}
				set
				{
					list.SetByIndex(index, value);
				}
			}

			public virtual IEnumerator GetEnumerator()
			{
				return new SortedListEnumerator(list, 0, list.Count, SortedListEnumerator.Values);
			}

			int IList.IndexOf(object value)
			{
				if (!(value is bool))
					throw new ArgumentException("The value must be of type: " + typeof(bool).FullName, "value");

				return list.IndexOfValue((bool)value);
			}

			public virtual int IndexOf(bool value)
			{
				return list.IndexOfValue(value);
			}

			public virtual void Remove(object key)
			{
				throw new NotSupportedException("Cannot modify a read-only list.");
			}

			public virtual void RemoveAt(int index)
			{
				throw new NotSupportedException("Cannot modify a read-only list.");
			}
		}
		#endregion
	}

}